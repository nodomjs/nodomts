(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["nodom"] = factory();
	else
		root["nodom"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./core/application.ts":
/*!*****************************!*\
  !*** ./core/application.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Application {}\n\n  nodom.Application = Application;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/application.ts?");

/***/ }),

/***/ "./core/compiler.ts":
/*!**************************!*\
  !*** ./core/compiler.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Compiler {\n    static compile(module, elementStr) {\n      const div = nodom.Util.newEl('div');\n      div.innerHTML = elementStr;\n      let oe = new nodom.Element();\n      oe.root = true;\n\n      for (let i = 0; i < div.childNodes.length; i++) {\n        this.compileDom(module, div.childNodes[i], oe);\n      }\n\n      return oe;\n    }\n\n    static compileDom(module, ele, parent) {\n      const me = this;\n      let oe = new nodom.Element();\n      let isComment = false;\n\n      switch (ele.nodeType) {\n        case Node.ELEMENT_NODE:\n          let el = ele;\n          oe.tagName = el.tagName;\n\n          for (let i = 0; i < el.attributes.length; i++) {\n            let attr = el.attributes[i];\n            let v = attr.value.trim();\n\n            if (attr.name.startsWith('x-')) {\n              oe.directives.push(new nodom.Directive(attr.name.substr(2), v, oe, module, el));\n            } else if (attr.name.startsWith('e-')) {\n              let en = attr.name.substr(2);\n              oe.events[en] = new nodom.NodomEvent(en, attr.value.trim());\n            } else {\n              let isExpr = false;\n\n              if (v !== '') {\n                let ra = me.compileExpression(module, v);\n\n                if (nodom.Util.isArray(ra)) {\n                  oe.exprProps[attr.name] = ra;\n                  isExpr = true;\n                }\n              }\n\n              if (!isExpr) {\n                oe.props[attr.name] = v;\n              }\n            }\n          }\n\n          let subEls = [];\n          ele.childNodes.forEach(nd => {\n            subEls.push(me.compileDom(module, nd, oe));\n          });\n          oe.directives.sort((a, b) => {\n            return nodom.DirectiveManager.getType(a.type).prio - nodom.DirectiveManager.getType(b.type).prio;\n          });\n          break;\n\n        case Node.TEXT_NODE:\n          let txt = ele.textContent;\n\n          if (txt === \"\") {\n            return;\n          }\n\n          let expA = me.compileExpression(module, txt);\n\n          if (typeof expA === 'string') {\n            oe.textContent = expA;\n          } else {\n            oe.expressions = expA;\n          }\n\n          break;\n\n        case Node.COMMENT_NODE:\n          isComment = true;\n          break;\n      }\n\n      if (!isComment && parent) {\n        parent.children.push(oe);\n      }\n\n      return oe;\n    }\n\n    static compileExpression(module, exprStr) {\n      if (/\\{\\{.+?\\}\\}/.test(exprStr) === false) {\n        return exprStr;\n      }\n\n      let reg = /\\{\\{.+?\\}\\}/g;\n      let retA = new Array();\n      let re;\n      let oIndex = 0;\n\n      while ((re = reg.exec(exprStr)) !== null) {\n        let ind = re.index;\n\n        if (ind > oIndex) {\n          let s = exprStr.substring(oIndex, ind);\n          retA.push(s);\n        }\n\n        let exp = new nodom.Expression(re[0].substring(2, re[0].length - 2), module);\n        module.expressionFactory.add(exp.id, exp);\n        retA.push(exp.id);\n        oIndex = ind + re[0].length;\n      }\n\n      if (oIndex < exprStr.length - 1) {\n        retA.push(exprStr.substr(oIndex));\n      }\n\n      return retA;\n    }\n\n  }\n\n  nodom.Compiler = Compiler;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/compiler.ts?");

/***/ }),

/***/ "./core/directive.ts":
/*!***************************!*\
  !*** ./core/directive.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Directive {\n    constructor(type, value, vdom, module, el) {\n      this.id = nodom.Util.genId();\n      this.type = type;\n\n      if (nodom.Util.isString(value)) {\n        this.value = value.trim();\n      }\n\n      if (type !== undefined) {\n        nodom.Util.apply(nodom.DirectiveManager.init, nodom.DirectiveManager, [this, vdom, module, el]);\n      }\n    }\n\n    exec(value) {\n      let args = [this.module, this.type, value];\n      return nodom.Util.apply(nodom.DirectiveManager.exec, nodom.DirectiveManager, args);\n    }\n\n  }\n\n  nodom.Directive = Directive;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/directive.ts?");

/***/ }),

/***/ "./core/directivefactory.ts":
/*!**********************************!*\
  !*** ./core/directivefactory.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class DirectiveFactory extends nodom.Factory {}\n\n  nodom.DirectiveFactory = DirectiveFactory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/directivefactory.ts?");

/***/ }),

/***/ "./core/directivemanager.ts":
/*!**********************************!*\
  !*** ./core/directivemanager.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class DirectiveManager {\n    static addType(name, config, replacable) {\n      if (this.directiveTypes.has(name)) {\n        throw new nodom.NodomError('exist1', nodom.TipWords.directiveType, name);\n      }\n\n      if (!nodom.Util.isObject(config)) {\n        throw new nodom.NodomError('invoke', 'DirectiveManager.addType', '1', 'Function');\n      }\n\n      config.prio = config.prio || 10;\n\n      if (replacable && !this.cantEditTypes.includes(name)) {\n        this.cantEditTypes.push(name);\n      }\n\n      this.directiveTypes.set(name, config);\n    }\n\n    static removeType(name) {\n      if (this.cantEditTypes.indexOf(name) !== -1) {\n        throw new nodom.NodomError('notupd', nodom.TipWords.system + nodom.TipWords.directiveType, name);\n      }\n\n      if (!this.directiveTypes.has(name)) {\n        throw new nodom.NodomError('notexist1', nodom.TipWords.directiveType, name);\n      }\n\n      this.directiveTypes.delete(name);\n    }\n\n    static getType(name) {\n      return this.directiveTypes.get(name);\n    }\n\n    static hasType(name) {\n      return this.directiveTypes.has(name);\n    }\n\n    static init(directive, dom, module, el) {\n      let dt = this.directiveTypes.get(directive.type);\n\n      if (dt === undefined) {\n        throw new nodom.NodomError('notexist1', nodom.TipWords.directiveType, name);\n      }\n\n      return dt.init(directive, dom, module, el);\n    }\n\n    static exec(directive, dom, module, parent) {\n      if (!this.directiveTypes.has(directive.type)) {\n        throw new nodom.NodomError('notexist1', nodom.TipWords.directiveType, directive.type);\n      }\n\n      return nodom.Util.apply(this.directiveTypes.get(directive.type).handle, null, [directive, dom, module, parent]);\n    }\n\n  }\n\n  DirectiveManager.directiveTypes = new Map();\n  DirectiveManager.cantEditTypes = ['model', 'repeat', 'if', 'else', 'show', 'class', 'field'];\n  nodom.DirectiveManager = DirectiveManager;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/directivemanager.ts?");

/***/ }),

/***/ "./core/element.ts":
/*!*************************!*\
  !*** ./core/element.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class ChangedDom {\n    constructor(node, type, parent, index) {\n      this.node = node;\n      this.type = type;\n      this.parent = parent;\n      this.index = index;\n    }\n\n  }\n\n  nodom.ChangedDom = ChangedDom;\n\n  class Element {\n    constructor(tag) {\n      this.directives = [];\n      this.props = {};\n      this.exprProps = {};\n      this.events = {};\n      this.expressions = [];\n      this.children = [];\n      this.dontRender = false;\n      this.tagName = tag;\n      this.key = nodom.Util.genId() + '';\n    }\n\n    render(module, parent) {\n      if (parent) {\n        this.parentKey = parent.key;\n\n        if (!this.modelId) {\n          this.modelId = parent.modelId;\n        }\n      }\n\n      if (this.tagName !== undefined) {\n        this.handleProps(module);\n        this.handleDirectives(module, parent);\n      } else {\n        this.handleTextContent(module);\n      }\n\n      if (!this.dontRender) {\n        for (let i = 0; i < this.children.length; i++) {\n          let item = this.children[i];\n          item.render(module, this);\n\n          if (item.dontRender) {\n            this.removeChild(item);\n            i--;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    renderToHtml(module, params) {\n      let el;\n      let el1;\n      let type = params.type;\n      let parent = params.parent;\n\n      if (!parent) {\n        el = module.container;\n      } else {\n        if (type === 'fresh' || type === 'add' || type === 'text') {\n          el = module.container.querySelector(\"[key='\" + parent.key + \"']\");\n        } else if (this.tagName !== undefined) {\n          el = module.container.querySelector(\"[key='\" + this.key + \"']\");\n        }\n      }\n\n      if (!el) {\n        return;\n      }\n\n      switch (type) {\n        case 'fresh':\n          if (this.tagName) {\n            el1 = newEl(this, null, el);\n            genSub(el1, this);\n          } else {\n            el1 = newText(this.textContent, this);\n          }\n\n          el.appendChild(el1);\n          break;\n\n        case 'text':\n          if (!parent || !parent.children) {\n            break;\n          }\n\n          let ind = parent.children.indexOf(this);\n\n          if (ind !== -1) {\n            if (this.type === 'html') {\n              let div = document.querySelector(\"[key='\" + this.key + \"']\");\n\n              if (div !== null) {\n                div.innerHTML = '';\n                div.appendChild(this.textContent);\n              } else {\n                let div = newText(this.textContent);\n                nodom.Util.replaceNode(el.childNodes[ind], div);\n              }\n            } else {\n              el.childNodes[ind].textContent = this.textContent;\n            }\n          }\n\n          break;\n\n        case 'upd':\n          if (params.removeProps) {\n            params.removeProps.forEach(p => {\n              el.removeAttribute(p);\n            });\n          }\n\n          if (params.changeProps) {\n            params.changeProps.forEach(p => {\n              if (el.tagName === 'INPUT' && p.k === 'value') {\n                el.value = p.v;\n              } else {\n                el.setAttribute(p.k, p.v);\n              }\n            });\n          }\n\n          break;\n\n        case 'rep':\n          el1 = newEl(this, parent);\n          nodom.Util.replaceNode(el, el1);\n          break;\n\n        case 'add':\n          if (this.tagName) {\n            el1 = newEl(this, parent, el);\n            genSub(el1, this);\n          } else {\n            el1 = newText(this.textContent);\n          }\n\n          if (params.index === el.childNodes.length) {\n            el.appendChild(el1);\n          } else {\n            el.insertBefore(el1, el.childNodes[params.index]);\n          }\n\n      }\n\n      function newEl(vdom, parent, parentEl) {\n        let el = document.createElement(vdom.tagName);\n        nodom.Util.getOwnProps(vdom.props).forEach(k => {\n          el.setAttribute(k, vdom.props[k]);\n        });\n        el.setAttribute('key', vdom.key);\n        vdom.handleEvents(module, el, parent, parentEl);\n        return el;\n      }\n\n      function newText(text, dom) {\n        if (dom && 'html' === dom.type) {\n          let div = nodom.Util.newEl('div');\n          div.setAttribute('key', dom.key);\n          div.appendChild(text);\n          return div;\n        } else {\n          return document.createTextNode(text);\n        }\n      }\n\n      function genSub(pEl, vNode) {\n        if (vNode.children && vNode.children.length > 0) {\n          vNode.children.forEach(item => {\n            let el1;\n\n            if (item.tagName) {\n              el1 = newEl(item, vNode, pEl);\n              genSub(el1, item);\n            } else {\n              el1 = newText(item.textContent, item);\n            }\n\n            pEl.appendChild(el1);\n          });\n        }\n      }\n    }\n\n    clone() {\n      let dst = new Element();\n      nodom.Util.getOwnProps(this).forEach(p => {\n        if (typeof this[p] !== 'object') {\n          dst[p] = this[p];\n        }\n      });\n\n      for (let d of this.directives) {\n        dst.directives.push(d);\n      }\n\n      nodom.Util.getOwnProps(this.props).forEach(k => {\n        dst.props[k] = this.props[k];\n      });\n      nodom.Util.getOwnProps(this.exprProps).forEach(k => {\n        dst.exprProps[k] = this.exprProps[k];\n      });\n      nodom.Util.getOwnProps(this.events).forEach(k => {\n        dst.events[k] = this.events[k].clone();\n      });\n      dst.expressions = this.expressions;\n      this.children.forEach(d => {\n        dst.children.push(d.clone());\n      });\n      return dst;\n    }\n\n    handleDirectives(module, parent) {\n      if (this.dontRender) {\n        return false;\n      }\n\n      const dirs = this.directives;\n\n      for (let i = 0; i < dirs.length && !this.dontRender; i++) {\n        nodom.DirectiveManager.exec(dirs[i], this, module, parent);\n      }\n\n      return true;\n    }\n\n    handleExpression(exprArr, module) {\n      if (this.dontRender) {\n        return;\n      }\n\n      let value = '';\n      let model = module.modelFactory.get(this.modelId);\n      exprArr.forEach(v => {\n        if (typeof v === 'number') {\n          let v1 = module.expressionFactory.get(v).val(model);\n\n          if (v1 instanceof DocumentFragment || nodom.Util.isEl(v1)) {\n            this.type = 'html';\n            return v1;\n          }\n\n          value += v1;\n        } else {\n          value += v;\n        }\n      });\n      return value;\n    }\n\n    handleProps(module) {\n      if (this.dontRender) {\n        return;\n      }\n\n      nodom.Util.getOwnProps(this.exprProps).forEach(k => {\n        if (nodom.Util.isArray(this.exprProps[k])) {\n          this.props[k] = this.handleExpression(this.exprProps[k], module);\n        } else if (this.exprProps[k] instanceof nodom.Expression) {\n          this.props[k] = this.exprProps[k].val(module.modelFactory.get(this.modelId));\n        }\n      });\n    }\n\n    handleTextContent(module) {\n      if (this.dontRender) {\n        return;\n      }\n\n      if (this.expressions !== undefined && this.expressions.length > 0) {\n        this.textContent = this.handleExpression(this.expressions, module);\n      }\n    }\n\n    handleEvents(module, el, parent, parentEl) {\n      if (nodom.Util.isEmpty(this.events)) {\n        return;\n      }\n\n      nodom.Util.getOwnProps(this.events).forEach(k => {\n        let ev = this.events[k];\n\n        if (ev.delg && parent) {\n          ev.delegateTo(module, this, el, parent, parentEl);\n        } else {\n          ev.bind(module, this, el);\n        }\n      });\n    }\n\n    removeDirectives(delDirectives) {\n      for (let i = this.directives.length - 1; i >= 0; i--) {\n        let d = this.directives[i];\n\n        for (let j = 0; j < delDirectives.length; j++) {\n          if (d.type === delDirectives[j]) {\n            this.directives.splice(i, 1);\n          }\n        }\n      }\n    }\n\n    hasDirective(directiveType) {\n      for (let i = 0; i < this.directives.length; i++) {\n        if (this.directives[i].type === directiveType) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    getDirective(directiveType) {\n      for (let i = 0; i < this.directives.length; i++) {\n        if (this.directives[i].type === directiveType) {\n          return this.directives[i];\n        }\n      }\n    }\n\n    add(dom) {\n      this.children.push(dom);\n    }\n\n    remove(module, delHtml) {\n      if (this.parentKey !== undefined) {\n        let p = module.renderTree.query(this.parentKey);\n\n        if (p) {\n          p.removeChild(this);\n        }\n      }\n\n      if (delHtml && module && module.container) {\n        let el = module.container.querySelector(\"[key='\" + this.key + \"']\");\n\n        if (el !== null) {\n          nodom.Util.remove(el);\n        }\n      }\n    }\n\n    removeFromHtml(module) {\n      let el = module.container.querySelector(\"[key='\" + this.key + \"']\");\n\n      if (el !== null) {\n        nodom.Util.remove(el);\n      }\n    }\n\n    removeChild(dom) {\n      let ind;\n\n      if (nodom.Util.isArray(this.children) && (ind = this.children.indexOf(dom)) !== -1) {\n        this.children.splice(ind, 1);\n      }\n    }\n\n    replace(dst) {\n      if (!dst.parent) {\n        return false;\n      }\n\n      let ind = dst.parent.children.indexOf(dst);\n\n      if (ind === -1) {\n        return false;\n      }\n\n      dst.parent.children.splice(ind, 1, this);\n      return true;\n    }\n\n    contains(dom) {\n      for (; dom !== undefined && dom !== this; dom = dom.parent);\n\n      return dom !== undefined;\n    }\n\n    query(key) {\n      if (this.key === key) {\n        return this;\n      }\n\n      for (let i = 0; i < this.children.length; i++) {\n        let dom = this.children[i].query(key);\n\n        if (dom) {\n          return dom;\n        }\n      }\n    }\n\n    compare(dst, retArr, parentNode) {\n      if (!dst) {\n        return;\n      }\n\n      let re = new ChangedDom();\n      let change = false;\n\n      if (this.tagName === undefined) {\n        if (dst.tagName === undefined) {\n          if (this.textContent !== dst.textContent) {\n            re.type = 'text';\n            change = true;\n          }\n        } else {\n          re.type = 'rep';\n          change = true;\n        }\n      } else {\n        if (this.tagName !== dst.tagName) {\n          re.type = 'rep';\n          change = true;\n        } else {\n          re.changeProps = [];\n          re.removeProps = [];\n          nodom.Util.getOwnProps(dst.props).forEach(k => {\n            if (!this.props[k]) {\n              re.removeProps.push(k);\n            }\n          });\n          nodom.Util.getOwnProps(this.props).forEach(k => {\n            let v1 = dst.props[k];\n\n            if (this.props[k] !== v1) {\n              re.changeProps.push({\n                k: k,\n                v: this.props[k]\n              });\n            }\n          });\n\n          if (re.changeProps.length > 0 || re.removeProps.length > 0) {\n            change = true;\n            re.type = 'upd';\n          }\n        }\n      }\n\n      if (change) {\n        re.node = this;\n\n        if (parentNode) {\n          re.parent = parentNode;\n        }\n\n        retArr.push(re);\n      }\n\n      if (!this.children || this.children.length === 0) {\n        if (dst.children && dst.children.length > 0) {\n          dst.children.forEach(item => {\n            retArr.push(new ChangedDom(item, 'del'));\n          });\n        }\n      } else {\n        if (!dst.children || dst.children.length === 0) {\n          this.children.forEach(item => {\n            retArr.push(new ChangedDom(item, 'add', this));\n          });\n        } else {\n          this.children.forEach((dom1, ind) => {\n            let dom2 = dst.children[ind];\n\n            if (!dom2 || dom1.key !== dom2.key) {\n              dom2 = undefined;\n\n              for (let i = 0; i < dst.children.length; i++) {\n                if (dom1.key === dst.children[i].key) {\n                  dom2 = dst.children[i];\n                  break;\n                }\n              }\n            }\n\n            if (dom2 !== undefined) {\n              dom1.compare(dom2, retArr, this);\n              dom2.finded = true;\n            } else {\n              retArr.push(new ChangedDom(dom1, 'add', this, ind));\n            }\n          });\n\n          if (dst.children && dst.children.length > 0) {\n            dst.children.forEach(item => {\n              if (!item.finded) {\n                retArr.push(new ChangedDom(item, 'del', dst));\n              }\n            });\n          }\n        }\n      }\n    }\n\n  }\n\n  nodom.Element = Element;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/element.ts?");

/***/ }),

/***/ "./core/expression.ts":
/*!****************************!*\
  !*** ./core/expression.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Expression {\n    constructor(exprStr, module) {\n      this.modelMap = {};\n      this.fields = [];\n      this.id = nodom.Util.genId();\n\n      if (module) {\n        this.moduleName = module.name;\n        module.expressionFactory.add(this.id, this);\n      }\n\n      if (exprStr) {\n        this.stack = this.init(exprStr);\n      }\n    }\n\n    init(exprStr) {\n      let startStr;\n      let type = 0;\n      let strings = \"'`\\\"\";\n      let operand = \"()!|*/+-><=&%\";\n      let spaceChar = \" \t\";\n      let stack = [];\n      let sTmp = '';\n\n      for (let i = 0; i < exprStr.length; i++) {\n        let c = exprStr[i];\n\n        if (type !== 1 && spaceChar.indexOf(c) !== -1) {\n          continue;\n        }\n\n        switch (type) {\n          case 1:\n            if (strings.indexOf(c) !== -1) {\n              if (c === startStr) {\n                this.addStr(sTmp + c, stack);\n                startStr = undefined;\n                sTmp = '';\n                type = 0;\n                continue;\n              }\n            }\n\n            break;\n\n          case 2:\n            if (operand.indexOf(c) !== -1) {\n              if (c === '(') {\n                type = 3;\n              } else {\n                this.addVar(sTmp, stack);\n                sTmp = '';\n                type = 0;\n              }\n            }\n\n            break;\n\n          case 3:\n            if (c === ')') {\n              let a = sTmp.trim().split('(');\n              let fn = a[0];\n              let pa = a[1].split(',');\n\n              for (let j = 0; j < pa.length; j++) {\n                let field = pa[j].trim();\n                pa[j] = field;\n                this.addField(field);\n              }\n\n              stack.push({\n                val: fn,\n                params: pa,\n                type: 'function'\n              });\n              sTmp = '';\n              type = 0;\n              continue;\n            }\n\n            break;\n\n          default:\n            if (strings.indexOf(c) !== -1) {\n              startStr = c;\n              type = 1;\n            } else if (operand.indexOf(c) === -1) {\n              type = 2;\n\n              if (sTmp !== '') {\n                this.addStr(sTmp, stack);\n                sTmp = '';\n              }\n            }\n\n        }\n\n        let isFilter = false;\n\n        if (c === '|') {\n          let j = i + 1;\n          let nextc = exprStr[j];\n\n          if (nextc >= 'a' && nextc <= 'z') {\n            let strCh = '';\n\n            for (; j < exprStr.length; j++) {\n              let ch = exprStr[j];\n\n              if (strings.indexOf(ch) !== -1) {\n                if (ch === strCh) {\n                  strCh = '';\n                } else {\n                  strCh = ch;\n                }\n              }\n\n              if (strCh === '' && operand.indexOf(ch) !== -1) {\n                break;\n              }\n            }\n          }\n\n          if (j > i) {\n            let s = exprStr.substring(i + 1, j);\n\n            if (s !== '') {\n              let filterArr = nodom.FilterManager.explain(s);\n\n              if (nodom.FilterManager.hasType(filterArr[0])) {\n                this.addFilter(filterArr, stack);\n                c = '';\n                exprStr = '';\n                isFilter = true;\n              }\n            }\n          }\n        }\n\n        if (!isFilter && type !== 1 && type !== 3 && operand.indexOf(c) !== -1) {\n          this.addOperand(c, stack);\n        } else {\n          sTmp += c;\n        }\n      }\n\n      if (type === 2) {\n        this.addVar(sTmp, stack);\n      } else if (type === 0 && sTmp !== '') {\n        this.addStr(sTmp, stack);\n      } else if (type !== 0) {\n        throw new nodom.NodomError('invoke', 'expression', '0', 'Node');\n      }\n\n      return stack;\n    }\n\n    val(model, modelId) {\n      if (!model) {\n        return '';\n      }\n\n      if (this.stack === null) {\n        return '';\n      }\n\n      let fieldObj;\n\n      if (model instanceof nodom.Model) {\n        modelId = model.id;\n        fieldObj = Object.create(null);\n        this.fields.forEach(field => {\n          fieldObj[field] = this.getFieldValue(model, field);\n        });\n      } else {\n        fieldObj = model;\n      }\n\n      let newFieldValue = '';\n      this.fields.forEach(field => {\n        newFieldValue += fieldObj[field];\n      });\n\n      if (this.modelMap[modelId] === undefined) {\n        this.modelMap[modelId] = Object.create(null);\n      }\n\n      if (this.modelMap[modelId].fieldValue !== newFieldValue) {\n        this.modelMap[modelId].value = this.cacStack(this.stack, fieldObj, modelId);\n      }\n\n      this.modelMap[modelId].fieldValue = newFieldValue;\n      return this.modelMap[modelId].value;\n    }\n\n    addVar(field, stack) {\n      let values = ['null', 'undefined', 'true', 'false', 'NaN'];\n      let addFlag = values.indexOf(field) === -1 ? false : true;\n      addFlag = addFlag || nodom.Util.isNumberString(field);\n\n      if (addFlag) {\n        this.addStr(field, stack);\n      } else {\n        stack.push({\n          val: field.trim(),\n          type: 'field'\n        });\n        this.addField(field);\n      }\n    }\n\n    addStr(str, stack) {\n      if (stack.length > 0 && stack[stack.length - 1].type === \"string\") {\n        stack[stack.length - 1].val += str;\n      } else {\n        stack.push({\n          val: str,\n          type: 'string'\n        });\n      }\n    }\n\n    addOperand(str, stack) {\n      stack.push({\n        val: str,\n        type: 'operand'\n      });\n    }\n\n    addFilter(filterArr, stack) {\n      let module = nodom.ModuleFactory.get(this.moduleName);\n\n      if (stack.length > 0) {\n        let filterStack = [];\n        let pre = stack[stack.length - 1];\n        let type = pre.type;\n\n        if (type === 'field' || type === 'function' || type === 'string') {\n          filterStack.push(stack.pop());\n        } else if (type === 'operand' && pre.val === ')') {\n          let cnt = 1;\n          let j = stack.length - 2;\n\n          for (; j >= 0; j--) {\n            if (stack[j].val === '(') {\n              if (--cnt === 0) {\n                break;\n              }\n            } else if (stack[j].val === ')') {\n              cnt++;\n            }\n          }\n\n          filterStack = stack.slice(j, stack.length);\n          stack.splice(j, stack.length - j);\n        }\n\n        let expr = new Expression(null, module);\n        expr.stack = filterStack;\n        expr.fields = this.fields;\n\n        if (!this.pre) {\n          this.pre = [];\n        }\n\n        this.pre.push(expr.id);\n        stack.push({\n          type: 'filter',\n          filter: new nodom.Filter(filterArr),\n          val: expr.id\n        });\n      }\n    }\n\n    cacStack(stack, fieldObj, modelId) {\n      let retStr = '';\n      let needEval = false;\n      let module = nodom.ModuleFactory.get(this.moduleName);\n      stack.forEach(item => {\n        let value = '';\n\n        switch (item.type) {\n          case 'string':\n            retStr += item.val;\n            break;\n\n          case 'operand':\n            retStr += item.val;\n            needEval = true;\n            break;\n\n          case 'field':\n            value = fieldObj[item.val];\n\n            if (nodom.Util.isString(value)) {\n              value = nodom.Util.addStrQuot(value);\n            }\n\n            retStr += value;\n            break;\n\n          case 'function':\n            let foo = module.methodFactory.get(item.val);\n            let param = [];\n\n            if (item.params.length > 0) {\n              item.params.forEach(p => {\n                let pv = fieldObj[p];\n                let isVal = false;\n\n                if (nodom.Util.isString(pv) && pv !== '') {\n                  pv = nodom.Util.addStrQuot(pv);\n                }\n\n                param.push(pv);\n              });\n            }\n\n            if (foo !== undefined && nodom.Util.isFunction(foo)) {\n              value = foo.apply(module.model, param);\n            } else {\n              value = item.val + '(' + param.join(',') + ')';\n              needEval = true;\n            }\n\n            retStr += value;\n            break;\n\n          case 'filter':\n            value = module.expressionFactory.get(item.val).val(fieldObj, modelId);\n            value = item.filter.exec(value, module);\n\n            if (typeof value === 'object') {\n              retStr = value;\n            } else {\n              if (nodom.Util.isString(value) && value !== '') {\n                value = nodom.Util.addStrQuot(value);\n              }\n\n              retStr += value;\n            }\n\n        }\n      });\n\n      if (needEval) {\n        try {\n          retStr = eval(retStr);\n        } catch (e) {}\n      } else if (nodom.Util.isString(retStr) && retStr.charAt(0) === '\"') {\n        retStr = retStr.substring(1, retStr.length - 1);\n      }\n\n      if (retStr === undefined) {\n        retStr = '';\n      }\n\n      return retStr;\n    }\n\n    addField(field) {\n      if (this.fields.indexOf(field) === -1) {\n        this.fields.push(field);\n      }\n    }\n\n    getFieldValue(model, field) {\n      let module = nodom.ModuleFactory.get(this.moduleName);\n\n      if (!model && module) {\n        model = module.model;\n      }\n\n      if (!model) {\n        return undefined;\n      }\n\n      let v = model.query(field);\n\n      if (v === undefined && model !== module.model) {\n        v = module.model.query(field);\n      }\n\n      return v;\n    }\n\n  }\n\n  nodom.Expression = Expression;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/expression.ts?");

/***/ }),

/***/ "./core/expressionfactory.ts":
/*!***********************************!*\
  !*** ./core/expressionfactory.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class ExpressionFactory extends nodom.Factory {}\n\n  nodom.ExpressionFactory = ExpressionFactory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/expressionfactory.ts?");

/***/ }),

/***/ "./core/factory.ts":
/*!*************************!*\
  !*** ./core/factory.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Factory {\n    constructor(module) {\n      if (module !== undefined) {\n        this.moduleName = module.name;\n      }\n\n      this.items = Object.create(null);\n    }\n\n    add(name, item) {\n      this.items[name] = item;\n    }\n\n    get(name) {\n      return this.items[name];\n    }\n\n    remove(name) {\n      delete this.items[name];\n    }\n\n  }\n\n  nodom.Factory = Factory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/factory.ts?");

/***/ }),

/***/ "./core/filter.ts":
/*!************************!*\
  !*** ./core/filter.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Filter {\n    constructor(src) {\n      let arr = nodom.Util.isString(src) ? nodom.FilterManager.explain(src) : src;\n\n      if (arr) {\n        this.type = arr[0];\n        this.params = arr.slice(1);\n      }\n    }\n\n    exec(value, module) {\n      let args = [module, this.type, value].concat(this.params);\n      return nodom.Util.apply(nodom.FilterManager.exec, module, args);\n    }\n\n  }\n\n  nodom.Filter = Filter;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/filter.ts?");

/***/ }),

/***/ "./core/filterfactory.ts":
/*!*******************************!*\
  !*** ./core/filterfactory.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class FilterFactory extends nodom.Factory {}\n\n  nodom.FilterFactory = FilterFactory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/filterfactory.ts?");

/***/ }),

/***/ "./core/filtermanager.ts":
/*!*******************************!*\
  !*** ./core/filtermanager.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class FilterManager {\n    static addType(name, handler) {\n      if (!/^[a-zA-Z]+$/.test(name)) {\n        throw new nodom.NodomError('namedinvalid', nodom.TipWords.filterType, name);\n      }\n\n      if (this.filterTypes.has(name)) {\n        throw new nodom.NodomError('exist1', nodom.TipWords.filterType, name);\n      }\n\n      if (!nodom.Util.isFunction(handler)) {\n        throw new nodom.NodomError('invoke', 'FilterManager.addType', '1', 'Function');\n      }\n\n      this.filterTypes.set(name, handler);\n    }\n\n    static removeType(name) {\n      if (this.cantEditTypes.indexOf(name) !== -1) {\n        throw new nodom.NodomError('notupd', nodom.TipWords.system + nodom.TipWords.filterType, name);\n      }\n\n      if (!this.filterTypes.has(name)) {\n        throw new nodom.NodomError('notexist1', nodom.TipWords.filterType, name);\n      }\n\n      this.filterTypes.delete(name);\n    }\n\n    static hasType(name) {\n      return this.filterTypes.has(name);\n    }\n\n    static exec(module, type) {\n      let params = new Array();\n\n      for (let i = 2; i < arguments.length; i++) {\n        params.push(arguments[i]);\n      }\n\n      if (!FilterManager.filterTypes.has(type)) {\n        throw new nodom.NodomError('notexist1', nodom.TipWords.filterType, type);\n      }\n\n      return nodom.Util.apply(FilterManager.filterTypes.get(type), module, params);\n    }\n\n    static explain(src) {\n      let startStr;\n      let startObj = false;\n      let strings = \"\\\"'`\";\n      let splitCh = ':';\n      let retArr = new Array();\n      let tmp = '';\n\n      for (let i = 0; i < src.length; i++) {\n        let ch = src[i];\n\n        if (strings.indexOf(ch) !== -1) {\n          if (ch === startStr) {\n            startStr = undefined;\n          } else {\n            startStr = ch;\n          }\n        } else if (startStr === undefined) {\n          if (ch === '}' && startObj) {\n            startObj = false;\n          } else if (ch === '{') {\n            startObj = true;\n          }\n        }\n\n        if (ch === splitCh && startStr === undefined && !startObj && tmp !== '') {\n          retArr.push(handleObj(tmp));\n          tmp = '';\n          continue;\n        }\n\n        tmp += ch;\n      }\n\n      if (tmp !== '') {\n        retArr.push(handleObj(tmp));\n      }\n\n      return retArr;\n\n      function handleObj(s) {\n        s = s.trim();\n\n        if (s.charAt(0) === '{') {\n          s = eval('(' + s + ')');\n        }\n\n        return s;\n      }\n    }\n\n  }\n\n  FilterManager.filterTypes = new Map();\n  FilterManager.cantEditTypes = ['date', 'currency', 'number', 'tolowercase', 'touppercase', 'orderBy', 'filter'];\n  nodom.FilterManager = FilterManager;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/filtermanager.ts?");

/***/ }),

/***/ "./core/linker.ts":
/*!************************!*\
  !*** ./core/linker.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar nodom;\n\n(function (nodom) {\n  class Linker {\n    static gen(type, config) {\n      let p;\n\n      switch (type) {\n        case 'ajax':\n          p = this.ajax(config);\n          break;\n\n        case 'getfiles':\n          p = this.getfiles(config);\n          break;\n\n        case 'dolist':\n          if (config.params) {\n            p = this.dolist(config.funcs, config.params);\n          } else {\n            p = this.dolist(config.funcs);\n          }\n\n      }\n\n      return p;\n    }\n\n    static ajax(config) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n          if (config.rand) {\n            config.params = config.params || {};\n            config.params.$rand = Math.random();\n          }\n\n          let url = config.url;\n          const async = config.async === false ? false : true;\n          const req = new XMLHttpRequest();\n          req.withCredentials = config.withCredentials;\n          const reqType = config.reqType || 'GET';\n          req.timeout = async ? config.timeout : 0;\n\n          req.onload = () => {\n            if (req.status === 200) {\n              let r = req.responseText;\n\n              if (config.type === 'json') {\n                try {\n                  r = JSON.parse(r);\n                } catch (e) {\n                  reject({\n                    type: \"jsonparse\"\n                  });\n                }\n              }\n\n              resolve(r);\n            } else {\n              reject({\n                type: 'error',\n                url: url\n              });\n            }\n          };\n\n          req.ontimeout = () => reject({\n            type: 'timeout'\n          });\n\n          req.onerror = () => reject({\n            type: 'error',\n            url: url\n          });\n\n          switch (reqType) {\n            case 'GET':\n              let pa;\n\n              if (nodom.Util.isObject(config.params)) {\n                let ar = [];\n                nodom.Util.getOwnProps(config.params).forEach(function (key) {\n                  ar.push(key + '=' + config.params[key]);\n                });\n                pa = ar.join('&');\n              }\n\n              if (pa !== undefined) {\n                if (url.indexOf('?') !== -1) {\n                  url += '&' + pa;\n                } else {\n                  url += '?' + pa;\n                }\n              }\n\n              req.open(reqType, url, async, config.user, config.pwd);\n              req.send(null);\n              break;\n\n            case 'POST':\n              let fd = new FormData();\n\n              for (let o in config.params) {\n                fd.append(o, config.params[o]);\n              }\n\n              req.open(reqType, url, async, config.user, config.pwd);\n              req.send(fd);\n              break;\n          }\n        }).catch(re => {\n          switch (re.type) {\n            case \"error\":\n              throw new nodom.NodomError(\"notexist1\", nodom.TipWords.resource, re.url);\n\n            case \"timeout\":\n              throw new nodom.NodomError(\"timeout\");\n\n            case \"jsonparse\":\n              throw new nodom.NodomError(\"jsonparse\");\n          }\n        });\n      });\n    }\n\n    static getfiles(urls) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let promises = [];\n        urls.forEach(url => {\n          promises.push(new Promise((resolve, reject) => {\n            const req = new XMLHttpRequest();\n\n            req.onload = () => resolve(req.responseText);\n\n            req.onerror = () => reject(url);\n\n            req.open(\"GET\", url);\n            req.send();\n          }));\n        });\n        return Promise.all(promises).catch(text => {\n          throw new nodom.NodomError(\"notexist1\", nodom.TipWords.resource, text);\n        });\n      });\n    }\n\n    static dolist(funcArr, paramArr) {\n      return foo(funcArr, 0, paramArr);\n\n      function foo(fa, i, pa) {\n        if (fa.length === 0) {\n          return Promise.resolve();\n        } else {\n          return new Promise((resolve, reject) => {\n            if (nodom.Util.isArray(pa)) {\n              fa[i](resolve, reject, pa[i]);\n            } else {\n              fa[i](resolve, reject);\n            }\n          }).then(() => {\n            if (i < fa.length - 1) {\n              return foo(fa, i + 1, pa);\n            }\n          });\n        }\n      }\n    }\n\n  }\n\n  nodom.Linker = Linker;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/linker.ts?");

/***/ }),

/***/ "./core/messagequeue.ts":
/*!******************************!*\
  !*** ./core/messagequeue.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Message {\n    constructor(fromModule, toModule, content) {\n      this.fromModule = fromModule;\n      this.toModule = toModule;\n      this.content = content;\n      this.readed = false;\n    }\n\n  }\n\n  nodom.Message = Message;\n\n  class MessageQueue {\n    static add(from, to, data) {\n      this.messages.push(new Message(from, to, data));\n    }\n\n    static handleQueue() {\n      for (let i = 0; i < this.messages.length; i++) {\n        let msg = this.messages[i];\n        let module = nodom.ModuleFactory.get(msg.toModule);\n\n        if (module && module.state === 2 || module.state === 3) {\n          module.receive(msg.fromModule, msg.content);\n        }\n\n        if (module && module.state >= 2) {\n          MessageQueue.messages.splice(i--, 1);\n        }\n      }\n    }\n\n  }\n\n  MessageQueue.messages = [];\n  nodom.MessageQueue = MessageQueue;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/messagequeue.ts?");

/***/ }),

/***/ "./core/methodfactory.ts":
/*!*******************************!*\
  !*** ./core/methodfactory.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class MethodFactory extends nodom.Factory {\n    invoke(name, params) {\n      const foo = this.get(name);\n\n      if (!nodom.Util.isFunction(foo)) {\n        throw new nodom.NodomError(nodom.ErrorMsgs.notexist1, nodom.TipWords.method, name);\n      }\n\n      return nodom.Util.apply(foo, this.module.model, params);\n    }\n\n  }\n\n  nodom.MethodFactory = MethodFactory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/methodfactory.ts?");

/***/ }),

/***/ "./core/model.ts":
/*!***********************!*\
  !*** ./core/model.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Model {\n    constructor(data, module) {\n      this.fields = {};\n      this.data = data;\n      this.fields = {};\n      this.id = nodom.Util.genId();\n\n      if (module) {\n        this.moduleName = module.name;\n\n        if (module.modelFactory) {\n          module.modelFactory.add(this.id + '', this);\n        }\n      }\n\n      data['$modelId'] = this.id;\n      this.addSetterGetter(data);\n    }\n\n    set(key, value) {\n      let fn, data;\n      let index = key.lastIndexOf('.');\n\n      if (index !== -1) {\n        fn = key.substr(index + 1);\n        key = key.substr(0, index);\n        data = this.query(key);\n      } else {\n        fn = key;\n        data = this.data;\n      }\n\n      if (data === undefined) {\n        throw new nodom.NodomError('notexist1', nodom.TipWords.dataItem, key);\n      }\n\n      if (data[fn] !== value) {\n        let module = nodom.ModuleFactory.get(this.moduleName);\n\n        if (nodom.Util.isObject(value) || nodom.Util.isArray(value)) {\n          new Model(value, module);\n        }\n\n        let model = module.modelFactory.get(data.$modelId);\n\n        if (model) {\n          if (data[fn] === undefined) {\n            this.defineProp(data, fn);\n          }\n\n          model.update(fn, value);\n        }\n\n        data[fn] = value;\n      }\n    }\n\n    update(field, value) {\n      let change = false;\n\n      if (nodom.Util.isString(field)) {\n        if (this.fields[field] !== value) {\n          this.fields[field] = value;\n          change = true;\n        }\n      }\n\n      if (change) {\n        nodom.ModuleFactory.get(this.moduleName).dataChange();\n      }\n    }\n\n    addSetterGetter(data) {\n      if (nodom.Util.isObject(data)) {\n        nodom.Util.getOwnProps(data).forEach(p => {\n          let v = data[p];\n\n          if (nodom.Util.isObject(v) || nodom.Util.isArray(v)) {\n            new Model(v, nodom.ModuleFactory.get(this.moduleName));\n          } else {\n            this.update(p, v);\n            this.defineProp(data, p);\n          }\n        });\n      } else if (nodom.Util.isArray(data)) {\n        let watcher = ['push', 'unshift', 'splice', 'pop', 'shift', 'reverse', 'sort'];\n        let module = nodom.ModuleFactory.get(this.moduleName);\n        watcher.forEach(item => {\n          data[item] = () => {\n            let args = [];\n\n            switch (item) {\n              case 'push':\n                for (let i = 0; i < arguments.length; i++) {\n                  args.push(arguments[i]);\n                }\n\n                break;\n\n              case 'unshift':\n                for (let i = 0; i < arguments.length; i++) {\n                  args.push(arguments[i]);\n                }\n\n                break;\n\n              case 'splice':\n                if (arguments.length > 2) {\n                  for (let i = 2; i < arguments.length; i++) {\n                    args.push(arguments[i]);\n                  }\n                }\n\n                break;\n\n              case 'pop':\n                break;\n\n              case 'shift':\n                break;\n            }\n\n            this.update(data);\n            Array.prototype[item].apply(data, arguments);\n            args.forEach(arg => {\n              if (nodom.Util.isObject(arg) || nodom.Util.isArray(arg)) {\n                new Model(arg, nodom.ModuleFactory.get(this.moduleName));\n              }\n            });\n          };\n        });\n        data.forEach(item => {\n          if (nodom.Util.isObject(item) || nodom.Util.isArray(item)) {\n            new Model(item, nodom.ModuleFactory.get(this.moduleName));\n          }\n        });\n      }\n    }\n\n    defineProp(data, p) {\n      Object.defineProperty(data, p, {\n        set: v => {\n          if (this.fields[p] === v) {\n            return;\n          }\n\n          this.update(p, v);\n          data[p] = v;\n        },\n        get: () => {\n          if (this.fields[p] !== undefined) {\n            return this.fields[p];\n          }\n        }\n      });\n    }\n\n    query(name) {\n      let data = this.data;\n      let fa = name.split(\".\");\n\n      for (let i = 0; i < fa.length && null !== data && typeof data === 'object'; i++) {\n        if (data === undefined) {\n          return;\n        }\n\n        if (fa[i].charAt(fa[i].length - 1) === ']') {\n          let f = fa[i].split('[');\n          data = data[f[0]];\n          f.shift();\n          f.forEach(istr => {\n            let ind = istr.substr(0, istr.length - 1);\n            data = data[parseInt(ind)];\n          });\n        } else {\n          data = data[fa[i]];\n        }\n      }\n\n      return data;\n    }\n\n  }\n\n  nodom.Model = Model;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/model.ts?");

/***/ }),

/***/ "./core/modelfactory.ts":
/*!******************************!*\
  !*** ./core/modelfactory.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class ModelFactory extends nodom.Factory {}\n\n  nodom.ModelFactory = ModelFactory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/modelfactory.ts?");

/***/ }),

/***/ "./core/module.ts":
/*!************************!*\
  !*** ./core/module.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar nodom;\n\n(function (nodom) {\n  class Module {\n    constructor(config, main) {\n      this.firstRender = true;\n      this.children = [];\n      this.firstRenderOps = [];\n      this.beforeFirstRenderOps = [];\n      this.state = 0;\n      this.loadNewData = false;\n      this.renderDoms = [];\n\n      if (config.name) {\n        this.name = config.name;\n      } else {\n        this.name = 'Module' + nodom.Util.genId();\n      }\n\n      nodom.ModuleFactory.add(this.name, this);\n      this.methodFactory = new nodom.MethodFactory(this);\n      this.modelFactory = new nodom.ModelFactory(this);\n      this.expressionFactory = new nodom.ExpressionFactory(this);\n      this.directiveFactory = new nodom.DirectiveFactory(this);\n      this.renderDoms = [];\n\n      if (config) {\n        this.initConfig = config;\n\n        if (nodom.Util.isString(config.el)) {\n          this.containerParam = {\n            module: config.parentName,\n            selector: config.el\n          };\n        } else if (nodom.Util.isEl(config.el)) {\n          this.container = config.el;\n        }\n\n        if (nodom.Util.isObject(config.methods)) {\n          nodom.Util.getOwnProps(config.methods).forEach(item => {\n            this.methodFactory.add(item, config.methods[item]);\n          });\n        }\n\n        if (this.hasContainer()) {\n          this.template = this.container.innerHTML.trim();\n          this.container.innerHTML = '';\n        }\n\n        if (main) {\n          this.main = true;\n          nodom.ModuleFactory.setMain(this);\n          this.active();\n        }\n\n        if (!config.delayInit || this.main) {\n          this.init();\n        }\n      }\n    }\n\n    init() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.state !== 0 || this.initing) {\n          return this.initLinker;\n        }\n\n        this.initing = true;\n        let config = this.initConfig;\n        let typeArr = [];\n        let urlArr = [];\n        let appPath = nodom.Application.templatePath || '';\n\n        if (nodom.Util.isArray(config.requires) && config.requires.length > 0) {\n          const head = document.head;\n          config.requires.forEach(item => {\n            let type;\n            let url = '';\n\n            if (nodom.Util.isObject(item)) {\n              type = item['type'] || 'js';\n              url += item['url'];\n            } else {\n              type = 'js';\n              url += item;\n            }\n\n            if (type === 'css') {\n              let css = nodom.Util.get(\"link[href='\" + url + \"']\");\n\n              if (css !== null) {\n                return;\n              }\n\n              css = nodom.Util.newEl('link');\n              css.type = 'text/css';\n              css.rel = 'stylesheet';\n              css.href = url;\n              head.appendChild(css);\n              return;\n            } else if (type === 'js') {\n              let cs = nodom.Util.get(\"script[dsrc='\" + url + \"']\");\n\n              if (cs !== null) {\n                return;\n              }\n            }\n\n            typeArr.push(type);\n            urlArr.push(url);\n          });\n        }\n\n        let templateStr = this.template;\n\n        if (config.template) {\n          config.template = config.template.trim();\n          let ch = config.template.substr(0, 1);\n\n          if (ch === '<') {\n            templateStr = config.template;\n          } else {\n            if (config.template.lastIndexOf('.nd') === config.template.length - 3) {\n              typeArr.push('compiled');\n            } else {\n              typeArr.push('template');\n            }\n\n            urlArr.push(appPath + config.template);\n          }\n        }\n\n        if (!nodom.Util.isEmpty(templateStr)) {\n          this.virtualDom = nodom.Compiler.compile(this, templateStr);\n        }\n\n        if (config.data) {\n          if (nodom.Util.isObject(config.data)) {\n            this.model = new nodom.Model(config.data, this);\n          } else {\n            typeArr.push('data');\n            urlArr.push(config.data);\n            this.dataUrl = config.data;\n          }\n        }\n\n        if (typeArr.length > 0) {\n          this.initLinker = nodom.Linker.gen('getfiles', urlArr).then(files => {\n            let head = document.querySelector('head');\n            files.forEach((file, ind) => {\n              switch (typeArr[ind]) {\n                case 'js':\n                  let script = nodom.Util.newEl('script');\n                  script.innerHTML = file;\n                  head.appendChild(script);\n                  script.setAttribute('dsrc', urlArr[ind]);\n                  script.innerHTML = '';\n                  head.removeChild(script);\n                  break;\n\n                case 'template':\n                  this.virtualDom = nodom.Compiler.compile(this, file.trim());\n                  break;\n\n                case 'compiled':\n                  let arr = nodom.Serializer.deserialize(file, this);\n                  this.virtualDom = arr[0];\n                  this.expressionFactory = arr[1];\n                  break;\n\n                case 'data':\n                  this.model = new nodom.Model(JSON.parse(file), this);\n              }\n            });\n            changeState(this);\n            delete this.initing;\n          });\n        } else {\n          this.initLinker = Promise.resolve();\n          changeState(this);\n          delete this.initing;\n        }\n\n        if (nodom.Util.isArray(this.initConfig.modules)) {\n          this.initConfig.modules.forEach(item => {\n            this.addChild(item);\n          });\n        }\n\n        delete this.initConfig;\n        return this.initLinker;\n\n        function changeState(mod) {\n          if (mod.main) {\n            mod.state = 3;\n            nodom.Renderer.add(mod);\n          } else if (mod.parentName) {\n            mod.state = nodom.ModuleFactory.get(mod.parentName).state;\n          } else {\n            mod.state = 1;\n          }\n        }\n      });\n    }\n\n    render() {\n      if (this.state !== 3 || !this.virtualDom || !this.hasContainer()) {\n        return false;\n      }\n\n      let root = this.virtualDom.clone();\n\n      if (this.firstRender) {\n        if (this.loadNewData && this.dataUrl) {\n          nodom.Linker.gen('ajax', {\n            url: this.dataUrl,\n            type: 'json'\n          }).then(r => {\n            this.model = new nodom.Model(r, this);\n            this.doFirstRender(root);\n          });\n          this.loadNewData = false;\n        } else {\n          this.doFirstRender(root);\n        }\n      } else {\n        this.doModuleEvent('onBeforeRender');\n\n        if (this.model) {\n          root.modelId = this.model.id;\n          let oldTree = this.renderTree;\n          this.renderTree = root;\n          root.render(this, null);\n          root.compare(oldTree, this.renderDoms);\n\n          for (let i = this.renderDoms.length - 1; i >= 0; i--) {\n            let item = this.renderDoms[i];\n\n            if (item.type === 'del') {\n              item.node.removeFromHtml(this);\n              this.renderDoms.splice(i, 1);\n            }\n          }\n\n          this.renderDoms.forEach(item => {\n            item.node.renderToHtml(this, item);\n          });\n        }\n\n        this.doModuleEvent('onRender');\n      }\n\n      this.renderDoms = [];\n\n      if (nodom.Util.isArray(this.children)) {\n        this.children.forEach(item => {\n          item.render();\n        });\n      }\n\n      return true;\n    }\n\n    doFirstRender(root) {\n      let me = this;\n      this.doModuleEvent('onBeforeFirstRender');\n      this.beforeFirstRenderOps.forEach(foo => {\n        nodom.Util.apply(foo, me, []);\n      });\n      this.beforeFirstRenderOps = [];\n      this.renderTree = root;\n\n      if (this.model) {\n        root.modelId = this.model.id;\n      }\n\n      root.render(me, null);\n\n      if (root.children) {\n        root.children.forEach(item => {\n          item.renderToHtml(me, {\n            type: 'fresh'\n          });\n        });\n      }\n\n      delete this.firstRender;\n      this.doModuleEvent('onFirstRender');\n      this.firstRenderOps.forEach(foo => {\n        nodom.Util.apply(foo, me, []);\n      });\n      this.firstRenderOps = [];\n    }\n\n    hasContainer() {\n      if (this.container) {\n        return true;\n      } else if (this.containerParam !== undefined) {\n        let ct;\n\n        if (this.containerParam['module'] === undefined) {\n          ct = document;\n        } else {\n          let module = nodom.ModuleFactory.get(this.containerParam['module']);\n\n          if (module) {\n            ct = module.container;\n          }\n        }\n\n        if (ct) {\n          this.container = ct.querySelector(this.containerParam['selector']);\n          return this.container !== null;\n        }\n      }\n\n      return false;\n    }\n\n    dataChange() {\n      nodom.Renderer.add(this);\n    }\n\n    addChild(config) {\n      const me = this;\n      config.parentName = this.name;\n      let chd = new Module(config);\n\n      if (this.children === undefined) {\n        this.children = [];\n      }\n\n      this.children.push(chd);\n      return chd;\n    }\n\n    send(toName, data) {\n      nodom.MessageQueue.add(this.name, toName, data);\n    }\n\n    broadcast(data) {\n      if (this.parentName) {\n        let pmod = nodom.ModuleFactory.get(this.parentName);\n\n        if (pmod && pmod.children) {\n          this.send(pmod.name, data);\n          pmod.children.forEach(m => {\n            if (m === this) {\n              return;\n            }\n\n            this.send(m.name, data);\n          });\n        }\n      }\n\n      if (this.children !== undefined) {\n        this.children.forEach(m => {\n          this.send(m.name, data);\n        });\n      }\n    }\n\n    receive(fromName, data) {\n      this.doModuleEvent('onReceive', [fromName, data]);\n    }\n\n    active(callback) {\n      if (this.state === 3) {\n        return;\n      }\n\n      if (this.state === 0) {\n        this.init().then(() => {\n          this.state = 3;\n\n          if (nodom.Util.isFunction(callback)) {\n            callback(this.model);\n          }\n\n          nodom.Renderer.add(this);\n        });\n      } else {\n        this.state = 3;\n\n        if (callback) {\n          callback(this.model);\n        }\n\n        nodom.Renderer.add(this);\n      }\n\n      if (nodom.Util.isArray(this.children)) {\n        this.children.forEach(m => {\n          m.active(callback);\n        });\n      }\n    }\n\n    unactive() {\n      if (this.main || this.state === 2) {\n        return;\n      }\n\n      this.state = 2;\n      this.firstRender = true;\n      delete this.container;\n\n      if (nodom.Util.isArray(this.children)) {\n        this.children.forEach(m => {\n          m.unactive();\n        });\n      }\n    }\n\n    dead() {\n      if (this.state === 4) {\n        return;\n      }\n\n      this.state = 4;\n\n      if (nodom.Util.isArray(this.children)) {\n        this.children.forEach(m => {\n          m.unactive();\n        });\n      }\n    }\n\n    destroy() {\n      if (nodom.Util.isArray(this.children)) {\n        this.children.forEach(m => {\n          m.destroy();\n        });\n      }\n\n      nodom.ModuleFactory.remove(this.name);\n    }\n\n    doModuleEvent(eventName, param) {\n      let foo = this.methodFactory.get(eventName);\n\n      if (!nodom.Util.isFunction(foo)) {\n        return;\n      }\n\n      if (!param) {\n        param = [this.model];\n      } else {\n        param.unshift(this.model);\n      }\n\n      nodom.Util.apply(foo, this, param);\n    }\n\n    addFirstRenderOperation(foo) {\n      let me = this;\n\n      if (!nodom.Util.isFunction(foo)) {\n        return;\n      }\n\n      if (this.firstRenderOps.indexOf(foo) === -1) {\n        this.firstRenderOps.push(foo);\n      }\n    }\n\n    addBeforeFirstRenderOperation(foo) {\n      let me = this;\n\n      if (!nodom.Util.isFunction(foo)) {\n        return;\n      }\n\n      if (this.beforeFirstRenderOps.indexOf(foo) === -1) {\n        this.beforeFirstRenderOps.push(foo);\n      }\n    }\n\n  }\n\n  nodom.Module = Module;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/module.ts?");

/***/ }),

/***/ "./core/modulefactory.ts":
/*!*******************************!*\
  !*** ./core/modulefactory.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class ModuleFactory {\n    static add(name, item) {\n      this.items.set(name, item);\n    }\n\n    static get(name) {\n      return this.items.get(name);\n    }\n\n    static remove(name) {\n      this.items.delete(name);\n    }\n\n    static setMain(m) {\n      this.mainModule = m;\n    }\n\n    static getMain() {\n      return this.mainModule;\n    }\n\n  }\n\n  ModuleFactory.items = new Map();\n  nodom.ModuleFactory = ModuleFactory;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/modulefactory.ts?");

/***/ }),

/***/ "./core/nodom.ts":
/*!***********************!*\
  !*** ./core/nodom.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack://nodom/./core/nodom.ts?");

/***/ }),

/***/ "./core/nodomerror.ts":
/*!****************************!*\
  !*** ./core/nodomerror.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class NodomError extends Error {\n    constructor(errorName, p1, p2, p3, p4) {\n      super(errorName);\n      let msg = nodom.ErrorMsgs[errorName];\n\n      if (msg === undefined) {\n        this.message = \"未知错误\";\n        return;\n      }\n\n      let params = [];\n\n      if (p1) {\n        params.push(p1);\n      }\n\n      if (p2) {\n        params.push(p2);\n      }\n\n      if (p3) {\n        params.push(p3);\n      }\n\n      if (p4) {\n        params.push(p4);\n      }\n\n      this.message = nodom.Util.compileStr.apply(null, params);\n    }\n\n  }\n\n  nodom.NodomError = NodomError;\n  ;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/nodomerror.ts?");

/***/ }),

/***/ "./core/nodomevent.ts":
/*!****************************!*\
  !*** ./core/nodomevent.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class NodomEvent {\n    constructor(eventName, eventStr) {\n      this.name = eventName;\n\n      if (eventStr) {\n        eventStr.split(':').forEach((item, i) => {\n          item = item.trim();\n\n          if (i === 0) {\n            this.handler = item;\n          } else {\n            switch (item) {\n              case 'delg':\n                this.delg = true;\n                break;\n\n              case 'nopopo':\n                this.nopopo = true;\n                break;\n\n              case 'once':\n                this.once = true;\n                break;\n\n              case 'capture':\n                this.capture = true;\n                break;\n            }\n          }\n        });\n      }\n\n      let dtype = 'ontouchend' in document ? 1 : 2;\n\n      if (dtype === 1) {\n        switch (this.name) {\n          case 'click':\n            this.name = 'tap';\n            break;\n\n          case 'mousedown':\n            this.name = 'touchstart';\n            break;\n\n          case 'mouseup':\n            this.name = 'touchend';\n            break;\n\n          case 'mousemove':\n            this.name = 'touchmove';\n            break;\n        }\n      } else {\n        switch (this.name) {\n          case 'tap':\n            this.name = 'click';\n            break;\n\n          case 'touchstart':\n            this.name = 'mousedown';\n            break;\n\n          case 'touchend':\n            this.name = 'mouseup';\n            break;\n\n          case 'touchmove':\n            this.name = 'mousemove';\n            break;\n        }\n      }\n    }\n\n    fire(e, el, dom) {\n      const module = nodom.ModuleFactory.get(this.moduleName);\n\n      if (!module.hasContainer()) {\n        return;\n      }\n\n      if (!dom) {\n        dom = module.renderTree.query(this.domKey);\n      }\n\n      if (!el) {\n        el = module.container.querySelector(\"[key='\" + this.domKey + \"']\");\n      }\n\n      const model = module.modelFactory.get(dom.modelId);\n\n      if (this.capture) {\n        handleSelf(this, e, model, module, el, dom);\n        handleDelg(this, e, model, module, el, dom);\n      } else {\n        if (handleDelg(this, e, model, module, el, dom)) {\n          handleSelf(this, e, model, module, el, dom);\n        }\n      }\n\n      if (this.events !== undefined && this.events[this.name].length === 0 && this.handler === undefined) {\n        if (ExternalEvent.touches[this.name]) {\n          ExternalEvent.unregist(this, el);\n        } else {\n          if (el !== null) {\n            el.removeEventListener(this.name, this.handleListener);\n          }\n        }\n      }\n\n      function handleDelg(eObj, e, model, module, el, dom) {\n        if (eObj.events === undefined) {\n          return true;\n        }\n\n        let arr = eObj.events[eObj.name];\n\n        if (nodom.Util.isArray(arr)) {\n          if (arr.length > 0) {\n            for (let i = 0; i < arr.length; i++) {\n              if (arr[i].el && arr[i].el.contains(e.target)) {\n                arr[i].fire(e);\n\n                if (arr[i].once) {\n                  eObj.removeSubEvt(arr[i]);\n                }\n\n                if (arr[i].nopopo) {\n                  return false;\n                }\n              }\n            }\n          } else {\n            eObj.events.delete(eObj.name);\n          }\n        }\n\n        return true;\n      }\n\n      function handleSelf(eObj, e, model, module, el, dom) {\n        let foo = module.methodFactory.get(eObj.handler);\n\n        if (nodom.Util.isFunction(foo)) {\n          if (eObj.nopopo) {\n            e.stopPropagation();\n          }\n\n          nodom.Util.apply(foo, model, [e, module, el, dom]);\n\n          if (eObj.once) {\n            delete eObj.handler;\n          }\n        }\n      }\n    }\n\n    bind(module, dom, el) {\n      this.moduleName = module.name;\n      this.domKey = dom.key;\n\n      if (ExternalEvent.touches[this.name]) {\n        ExternalEvent.regist(this, el);\n      } else {\n        this.handleListener = e => {\n          this.fire(e, el, dom);\n        };\n\n        el.addEventListener(this.name, this.handleListener, this.capture);\n      }\n    }\n\n    delegateTo(module, vdom, el, parent, parentEl) {\n      this.domKey = vdom.key;\n      this.moduleName = module.name;\n\n      if (!parentEl) {\n        parentEl = document.body;\n      }\n\n      if (!parent.events.hasOwnProperty(this.name)) {\n        let ev = new NodomEvent(this.name);\n        ev.bind(module, parent, parentEl);\n        parent.events[this.name] = ev;\n      }\n\n      parent.events[this.name].addSubEvt(this);\n    }\n\n    addSubEvt(ev) {\n      if (!this.events) {\n        this.events = new Map();\n      }\n\n      if (!this.events.has(this.name)) {\n        this.events.set(this.name, new Array());\n      }\n\n      this.events.get(this.name).push(ev);\n    }\n\n    removeSubEvt(ev) {\n      if (this.events === undefined || this.events[ev.name] === undefined) {\n        return;\n      }\n\n      let ind = this.events[ev.name].indexOf(ev);\n\n      if (ind !== -1) {\n        this.events[ev.name].splice(ind, 1);\n\n        if (this.events[ev.name].length === 0) {\n          this.events.delete(ev.name);\n        }\n      }\n    }\n\n    clone() {\n      let evt = new NodomEvent(this.name);\n      let arr = ['delg', 'once', 'nopopo', 'useCapture', 'handler', 'handleEvent', 'module'];\n      arr.forEach(item => {\n        evt[item] = this[item];\n      });\n      return evt;\n    }\n\n  }\n\n  nodom.NodomEvent = NodomEvent;\n\n  class ExternalEvent {\n    static regist(evtObj, el) {\n      let touchEvts = ExternalEvent.touches[evtObj.name];\n\n      if (!nodom.Util.isEmpty(evtObj.touchListeners)) {\n        this.unregist(evtObj);\n      }\n\n      if (!el) {\n        const module = nodom.ModuleFactory.get(evtObj.moduleName);\n        el = module.container.querySelector(\"[key='\" + evtObj.domKey + \"']\");\n      }\n\n      evtObj.touchListeners = new Map();\n\n      if (touchEvts && el !== null) {\n        nodom.Util.getOwnProps(touchEvts).forEach(function (ev) {\n          evtObj.touchListeners[ev] = function (e) {\n            touchEvts[ev](e, evtObj);\n          };\n\n          el.addEventListener(ev, evtObj.touchListeners[ev], evtObj.capture);\n        });\n      }\n    }\n\n    static unregist(evtObj, el) {\n      const evt = ExternalEvent.touches[evtObj.name];\n\n      if (!el) {\n        const module = nodom.ModuleFactory.get(evtObj.moduleName);\n        el = module.container.querySelector(\"[key='\" + evtObj.domKey + \"']\");\n      }\n\n      if (evt) {\n        if (el !== null) {\n          nodom.Util.getOwnProps(evtObj.touchListeners).forEach(function (ev) {\n            el.removeEventListener(ev, evtObj.touchListeners[ev]);\n          });\n        }\n      }\n    }\n\n  }\n\n  ExternalEvent.touches = {};\n  nodom.ExternalEvent = ExternalEvent;\n  ExternalEvent.touches = {\n    tap: {\n      touchstart: function (e, evtObj) {\n        let tch = e.touches[0];\n        evtObj.extParams = {\n          pos: {\n            sx: tch.pageX,\n            sy: tch.pageY,\n            t: Date.now()\n          }\n        };\n      },\n      touchmove: function (e, evtObj) {\n        let pos = evtObj.extParams.pos;\n        let tch = e.touches[0];\n        let dx = tch.pageX - pos.sx;\n        let dy = tch.pageY - pos.sy;\n\n        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {\n          pos.move = true;\n        }\n      },\n      touchend: function (e, evtObj) {\n        let pos = evtObj.extParams.pos;\n        let dt = Date.now() - pos.t;\n\n        if (pos.move === true || dt > 200) {\n          return;\n        }\n\n        evtObj.fire(e);\n      }\n    },\n    swipe: {\n      touchstart: function (e, evtObj) {\n        let tch = e.touches[0];\n        let t = Date.now();\n        evtObj.extParams = {\n          swipe: {\n            oldTime: [t, t],\n            speedLoc: [{\n              x: tch.pageX,\n              y: tch.pageY\n            }, {\n              x: tch.pageX,\n              y: tch.pageY\n            }],\n            oldLoc: {\n              x: tch.pageX,\n              y: tch.pageY\n            }\n          }\n        };\n      },\n      touchmove: function (e, evtObj) {\n        let nt = Date.now();\n        let tch = e.touches[0];\n        let mv = evtObj.extParams['swipe'];\n\n        if (nt - mv.oldTime > 50) {\n          mv.speedLoc[0] = {\n            x: mv.speedLoc[1].x,\n            y: mv.speedLoc[1].y\n          };\n          mv.speedLoc[1] = {\n            x: tch.pageX,\n            y: tch.pageY\n          };\n          mv.oldTime[0] = mv.oldTime[1];\n          mv.oldTime[1] = nt;\n        }\n\n        mv.oldLoc = {\n          x: tch.pageX,\n          y: tch.pageY\n        };\n      },\n      touchend: function (e, evtObj) {\n        let mv = evtObj.extParams['swipe'];\n        let nt = Date.now();\n        let ind = nt - mv.oldTime[1] < 30 ? 0 : 1;\n        let dx = mv.oldLoc.x - mv.speedLoc[ind].x;\n        let dy = mv.oldLoc.y - mv.speedLoc[ind].y;\n        let s = Math.sqrt(dx * dx + dy * dy);\n        let dt = nt - mv.oldTime[ind];\n\n        if (dt > 300 || s < 10) {\n          return;\n        }\n\n        let v0 = s / dt;\n\n        if (v0 > 0.05) {\n          let sname = '';\n\n          if (dx < 0 && Math.abs(dy / dx) < 1) {\n            e.v0 = v0;\n            sname = 'swipeleft';\n          }\n\n          if (dx > 0 && Math.abs(dy / dx) < 1) {\n            e.v0 = v0;\n            sname = 'swiperight';\n          }\n\n          if (dy > 0 && Math.abs(dx / dy) < 1) {\n            e.v0 = v0;\n            sname = 'swipedown';\n          }\n\n          if (dy < 0 && Math.abs(dx / dy) < 1) {\n            e.v0 = v0;\n            sname = 'swipeup';\n          }\n\n          if (evtObj.name === sname) {\n            evtObj.fire(e);\n          }\n        }\n      }\n    }\n  };\n  ExternalEvent.touches['swipeleft'] = ExternalEvent.touches['swipe'];\n  ExternalEvent.touches['swiperight'] = ExternalEvent.touches['swipe'];\n  ExternalEvent.touches['swipeup'] = ExternalEvent.touches['swipe'];\n  ExternalEvent.touches['swipedown'] = ExternalEvent.touches['swipe'];\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/nodomevent.ts?");

/***/ }),

/***/ "./core/renderer.ts":
/*!**************************!*\
  !*** ./core/renderer.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Renderer {\n    static add(module) {\n      if (module.state !== 3) {\n        return;\n      }\n\n      if (this.waitList.indexOf(module.name) === -1) {\n        this.waitList.push(module.name);\n      }\n    }\n\n    static remove(module) {\n      let ind;\n\n      if ((ind = this.waitList.indexOf(module.name)) !== -1) {\n        this.waitList.splice(ind, 1);\n      }\n    }\n\n    static render() {\n      for (let i = 0; i < this.waitList.length; i++) {\n        let m = nodom.ModuleFactory.get(this.waitList[i]);\n\n        if (!m || m.render()) {\n          this.waitList.splice(i--, 1);\n        }\n      }\n    }\n\n  }\n\n  Renderer.waitList = [];\n  nodom.Renderer = Renderer;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/renderer.ts?");

/***/ }),

/***/ "./core/router.ts":
/*!************************!*\
  !*** ./core/router.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar nodom;\n\n(function (nodom) {\n  class Router {\n    static addPath(path) {\n      for (let i = 0; i < this.waitList.length; i++) {\n        let li = this.waitList[i];\n\n        if (li === path) {\n          return;\n        }\n\n        if (li.indexOf(path) === 0 && li.substr(path.length + 1, 1) === '/') {\n          return;\n        }\n      }\n\n      this.waitList.push(path);\n      this.load();\n    }\n\n    static load() {\n      if (this.loading || this.waitList.length === 0) {\n        return;\n      }\n\n      let path = this.waitList.shift();\n      this.loading = true;\n      this.start(path);\n    }\n\n    static start(path) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let diff = this.compare(this.currentPath, path);\n        let parentModule = diff[0] === null ? nodom.ModuleFactory.getMain() : nodom.ModuleFactory.get(diff[0].module);\n\n        for (let i = diff[1].length - 1; i >= 0; i--) {\n          const r = diff[1][i];\n\n          if (!r.module) {\n            continue;\n          }\n\n          let module = nodom.ModuleFactory.get(r.module);\n\n          if (nodom.Util.isFunction(this.onDefaultLeave)) {\n            this.onDefaultLeave(module.model);\n          }\n\n          if (nodom.Util.isFunction(r.onLeave)) {\n            r.onLeave(module.model);\n          }\n\n          module.unactive();\n        }\n\n        let showPath;\n\n        if (this.startStyle !== 2 && showPath) {\n          if (this.showPath && showPath.indexOf(this.showPath) === 0) {\n            history.replaceState(path, '', nodom.Application.routerPrePath + showPath);\n          } else {\n            history.pushState(path, '', nodom.Application.routerPrePath + showPath);\n          }\n\n          this.showPath = showPath;\n        }\n\n        if (diff[2].length === 0) {\n          let route = diff[0];\n\n          if (route !== null) {\n            setRouteParamToModel(route);\n\n            if (!route.useParentPath) {\n              showPath = route.fullPath;\n            }\n\n            route.setLinkActive(true);\n          }\n        } else {\n          for (let i = 0; i < diff[2].length; i++) {\n            let route = diff[2][i];\n\n            if (!route || !route.module) {\n              continue;\n            }\n\n            if (!route.useParentPath) {\n              showPath = route.fullPath;\n            }\n\n            if (!parentModule.routerKey) {\n              throw new nodom.NodomError('notexist', nodom.TipWords.routeView);\n            }\n\n            let module = nodom.ModuleFactory.get(route.module);\n            module.containerParam = {\n              module: parentModule.name,\n              selector: \"[key='\" + parentModule.routerKey + \"']\"\n            };\n            module.addBeforeFirstRenderOperation(function () {\n              nodom.Util.empty(module.container);\n            });\n            yield module.init();\n            route.setLinkActive(true);\n            setRouteParamToModel(route);\n\n            if (nodom.Util.isFunction(this.onDefaultEnter)) {\n              this.onDefaultEnter(module.model);\n            }\n\n            if (nodom.Util.isFunction(route.onEnter)) {\n              route.onEnter(module.model);\n            }\n\n            parentModule = module;\n          }\n        }\n\n        this.currentPath = path;\n        this.loading = false;\n        this.load();\n        Router.startStyle = 0;\n\n        function setRouteParamToModel(route) {\n          if (!route) {\n            return;\n          }\n\n          const module = nodom.ModuleFactory.get(route.module);\n          let model = module.model;\n          let o = {\n            path: route.path\n          };\n\n          if (!nodom.Util.isEmpty(route.data)) {\n            o['data'] = route.data;\n          }\n\n          if (!model) {\n            module.model = new nodom.Model({\n              $route: o\n            }, module);\n          } else {\n            model.data['$route'] = o;\n          }\n\n          nodom.Renderer.add(module);\n        }\n      });\n    }\n\n    static redirect(path) {\n      this.addPath(path);\n    }\n\n    static addRoute(route, parent) {\n      if (RouterTree.add(route, parent) === false) {\n        throw new nodom.NodomError(\"exist1\", nodom.TipWords.route, route.path);\n      }\n\n      this.routes.set(route.id, route);\n    }\n\n    static getRoute(path, last) {\n      if (!path) {\n        return null;\n      }\n\n      let routes = RouterTree.get(path);\n\n      if (routes === null || routes.length === 0) {\n        return null;\n      }\n\n      if (last) {\n        return [routes[routes.length - 1]];\n      } else {\n        return routes;\n      }\n    }\n\n    static compare(path1, path2) {\n      let arr1 = null;\n      let arr2 = null;\n\n      if (path1) {\n        arr1 = this.getRoute(path1);\n      }\n\n      if (path2) {\n        arr2 = this.getRoute(path2);\n      }\n\n      let len = 0;\n\n      if (arr1 !== null) {\n        len = arr1.length;\n      }\n\n      if (arr2 !== null) {\n        if (arr2.length < len) {\n          len = arr2.length;\n        }\n      } else {\n        len = 0;\n      }\n\n      let retArr1 = [];\n      let retArr2 = [];\n      let i = 0;\n\n      for (i = 0; i < len; i++) {\n        if (arr1[i].id === arr2[i].id) {\n          if (JSON.stringify(arr1[i].data) !== JSON.stringify(arr2[i].data)) {\n            i++;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (arr1 !== null) {\n        for (let j = i; j < arr1.length; j++) {\n          retArr1.push(arr1[j]);\n        }\n      }\n\n      if (arr2 !== null) {\n        for (let j = i; j < arr2.length; j++) {\n          retArr2.push(arr2[j]);\n        }\n      }\n\n      let p1 = null;\n      let p2 = null;\n\n      if (arr1 !== null && i > 0) {\n        for (let j = i - 1; j >= 0 && (p1 === null || p2 === null); j--) {\n          if (arr1[j].module !== undefined) {\n            if (p1 === null) {\n              p1 = arr1[j];\n            } else if (p2 === null) {\n              p2 = arr1[j];\n            }\n          }\n        }\n      }\n\n      return [p1, retArr1, retArr2, p2];\n    }\n\n    static changeActive(module, path) {\n      if (!module || !path || path === '') {\n        return;\n      }\n\n      let domArr = Router.activeDomMap.get(module.name);\n\n      if (!domArr) {\n        return;\n      }\n\n      domArr.forEach(item => {\n        let dom = module.renderTree.query(item);\n\n        if (!dom) {\n          return;\n        }\n\n        let domPath = dom.props['path'];\n\n        if (dom.exprProps.hasOwnProperty('active')) {\n          let model = module.modelFactory.get(dom.modelId);\n\n          if (!model) {\n            return;\n          }\n\n          let expr = module.expressionFactory.get(dom.exprProps['active'][0]);\n\n          if (!expr) {\n            return;\n          }\n\n          let field = expr.fields[0];\n\n          if (path === domPath || path.indexOf(domPath + '/') === 0) {\n            model.data[field] = true;\n          } else {\n            model.data[field] = false;\n          }\n        } else if (dom.props.hasOwnProperty('active')) {\n          if (path === domPath || path.indexOf(domPath + '/') === 0) {\n            dom.props['active'] = true;\n          } else {\n            dom.props['active'] = false;\n          }\n        }\n      });\n    }\n\n  }\n\n  Router.loading = false;\n  Router.routes = new Map();\n  Router.currentPath = '';\n  Router.showPath = '';\n  Router.waitList = [];\n  Router.currentIndex = 0;\n  Router.moduleRouteMap = new Map();\n  Router.startStyle = 0;\n  Router.activeDomMap = new Map();\n  nodom.Router = Router;\n\n  class Route {\n    constructor(config) {\n      this.params = [];\n      this.data = {};\n      this.children = [];\n      this.onEnter = config.onEnter;\n      this.onLeave = config.onLeave;\n      this.useParentPath = config.useParentPath;\n      this.path = config.path;\n      this.module = config.module instanceof nodom.Module ? config.module.name : config.module;\n\n      if (config.path === '') {\n        return;\n      }\n\n      this.id = nodom.Util.genId();\n\n      if (!config.notAdd) {\n        Router.addRoute(this, config.parent);\n      }\n\n      if (nodom.Util.isArray(config.routes)) {\n        config.routes.forEach(item => {\n          item.parent = this;\n          new Route(item);\n        });\n      }\n    }\n\n    setLinkActive(ancestor) {\n      let path = this.fullPath;\n      let module = nodom.ModuleFactory.get(this.module);\n\n      if (module && module.containerParam) {\n        let pm = nodom.ModuleFactory.get(module.containerParam['module']);\n\n        if (pm) {\n          Router.changeActive(pm, path);\n        }\n      }\n\n      if (ancestor && this.parent) {\n        this.parent.setLinkActive(true);\n      }\n    }\n\n  }\n\n  nodom.Route = Route;\n\n  class RouterTree {\n    static add(route, parent) {\n      if (!this.root) {\n        this.root = new Route({\n          path: \"\",\n          notAdd: true\n        });\n      }\n\n      let pathArr = route.path.split('/');\n      let node = parent || this.root;\n      let param = [];\n      let paramIndex = -1;\n      let prePath = '';\n\n      for (let i = 0; i < pathArr.length; i++) {\n        let v = pathArr[i].trim();\n\n        if (v === '') {\n          pathArr.splice(i--, 1);\n          continue;\n        }\n\n        if (v.startsWith(':')) {\n          if (param.length === 0) {\n            paramIndex = i;\n          }\n\n          param.push(v.substr(1));\n        } else {\n          paramIndex = -1;\n          param = [];\n          route.path = v;\n          let j = 0;\n\n          for (; j < node.children.length; j++) {\n            let r = node.children[j];\n\n            if (r.path === v) {\n              node = r;\n              break;\n            }\n          }\n\n          if (j === node.children.length) {\n            if (prePath !== '') {\n              node.children.push(new Route({\n                path: prePath,\n                notAdd: true\n              }));\n              node = node.children[node.children.length - 1];\n            }\n\n            prePath = v;\n          }\n        }\n\n        if (paramIndex === -1) {\n          route.params = [];\n        } else {\n          route.params = param;\n        }\n      }\n\n      if (node !== undefined && node !== route) {\n        route.path = prePath;\n        node.children.push(route);\n      }\n\n      return true;\n    }\n\n    static get(path) {\n      if (!this.root) {\n        throw new nodom.NodomError(\"notexist\", nodom.TipWords.root);\n      }\n\n      let pathArr = path.split('/');\n      let node = this.root;\n      let paramIndex = 0;\n      let retArr = [];\n      let fullPath = '';\n      let preNode = this.root;\n\n      for (let i = 0; i < pathArr.length; i++) {\n        let v = pathArr[i].trim();\n\n        if (v === '') {\n          continue;\n        }\n\n        let find = false;\n\n        for (let j = 0; j < node.children.length; j++) {\n          if (node.children[j].path === v) {\n            if (preNode !== this.root) {\n              preNode.fullPath = fullPath;\n              preNode.data = node.data;\n              retArr.push(preNode);\n            }\n\n            node = node.children[j];\n            node.data = {};\n            preNode = node;\n            find = true;\n            break;\n          }\n        }\n\n        fullPath += '/' + v;\n\n        if (!find) {\n          if (paramIndex < node.params.length) {\n            node.data[node.params[paramIndex++]] = v;\n          }\n        }\n      }\n\n      if (node !== this.root) {\n        node.fullPath = fullPath;\n        retArr.push(node);\n      }\n\n      return retArr;\n    }\n\n  }\n\n  window.addEventListener('popstate', function (e) {\n    const state = history.state;\n\n    if (!state) {\n      return;\n    }\n\n    Router.startStyle = 2;\n    Router.addPath(state);\n  });\n  nodom.DirectiveManager.addType('route', {\n    init: (directive, dom, module) => {\n      let value = directive.value;\n\n      if (nodom.Util.isEmpty(value)) {\n        return;\n      }\n\n      if (dom.tagName === 'A') {\n        dom.props['href'] = 'javascript:void(0)';\n      }\n\n      if (value && value.substr(0, 2) === '{{' && value.substr(value.length - 2, 2) === '}}') {\n        let expr = new nodom.Expression(value.substring(2, value.length - 2), module);\n        dom.exprProps['path'] = expr;\n        directive.value = expr;\n      } else {\n        dom.props['path'] = value;\n      }\n\n      let method = '$nodomGenMethod' + nodom.Util.genId();\n      module.methodFactory.add(method, (e, module, view, dom) => {\n        let path = dom.props['path'];\n\n        if (nodom.Util.isEmpty(path)) {\n          return;\n        }\n\n        Router.addPath(path);\n      });\n      dom.events['click'] = new nodom.NodomEvent('click', method);\n    },\n    handle: (directive, dom, module, parent) => {\n      if (dom.props.hasOwnProperty('active')) {\n        let domArr = Router.activeDomMap.get(module.name);\n\n        if (!domArr) {\n          Router.activeDomMap.set(module.name, [dom.key]);\n        } else {\n          if (!domArr.includes(dom.key)) {\n            domArr.push(dom.key);\n          }\n        }\n\n        let route = Router.getRoute(dom.props['path'], true);\n\n        if (route === null) {\n          return;\n        }\n      }\n\n      let path = dom.props['path'];\n\n      if (path === Router.currentPath) {\n        return;\n      }\n\n      if (dom.props.hasOwnProperty('active') && dom.props['active'] !== 'false' && (!Router.currentPath || path.indexOf(Router.currentPath) === 0)) {\n        Router.addPath(path);\n      }\n    }\n  });\n  nodom.DirectiveManager.addType('router', {\n    init: (directive, dom, module) => {\n      module.routerKey = dom.key;\n    },\n    handle: (directive, dom, module, parent) => {\n      return;\n    }\n  });\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/router.ts?");

/***/ }),

/***/ "./core/scheduler.ts":
/*!***************************!*\
  !*** ./core/scheduler.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Scheduler {\n    static dispatch() {\n      Scheduler.tasks.forEach(item => {\n        if (nodom.Util.isFunction(item.func)) {\n          if (item.thiser) {\n            item.func.call(item.thiser);\n          } else {\n            item.func();\n          }\n        }\n      });\n    }\n\n    static start() {\n      Scheduler.dispatch();\n\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(Scheduler.start);\n      } else {\n        window.setTimeout(Scheduler.start, nodom.Application.renderTick);\n      }\n    }\n\n    static addTask(foo, thiser) {\n      if (!nodom.Util.isFunction(foo)) {\n        throw new nodom.NodomError(\"invoke\", \"Scheduler.addTask\", \"0\", \"function\");\n      }\n\n      Scheduler.tasks.push({\n        func: foo,\n        thiser: thiser\n      });\n    }\n\n    static removeTask(foo) {\n      if (!nodom.Util.isFunction(foo)) {\n        throw new nodom.NodomError(\"invoke\", \"Scheduler.removeTask\", \"0\", \"function\");\n      }\n\n      let ind = -1;\n\n      if ((ind = Scheduler.tasks.indexOf(foo)) !== -1) {\n        Scheduler.tasks.splice(ind, 1);\n      }\n    }\n\n  }\n\n  Scheduler.tasks = [];\n  nodom.Scheduler = Scheduler;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/scheduler.ts?");

/***/ }),

/***/ "./core/serializer.ts":
/*!****************************!*\
  !*** ./core/serializer.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Serializer {\n    static serialize(module) {\n      let props = ['virtualDom', 'expressionFactory'];\n      let jsonStr = '[';\n      props.forEach((p, i) => {\n        addClsName(module[p]);\n        let s = JSON.stringify(module[p]);\n        jsonStr += s;\n\n        if (i < props.length - 1) {\n          jsonStr += ',';\n        } else {\n          jsonStr += ']';\n        }\n      });\n      return jsonStr;\n\n      function addClsName(obj) {\n        if (typeof obj !== 'object') {\n          return;\n        }\n\n        obj.className = obj.constructor.name;\n        nodom.Util.getOwnProps(obj).forEach(item => {\n          if (nodom.Util.isArray(obj[item])) {\n            if (obj[item].length === 0) {\n              delete obj[item];\n            } else {\n              obj[item].forEach(item1 => {\n                addClsName(item1);\n              });\n            }\n          } else if (typeof obj[item] === 'object') {\n            if (nodom.Util.isEmpty(obj[item])) {\n              delete obj[item];\n            } else {\n              addClsName(obj[item]);\n            }\n          }\n        });\n      }\n    }\n\n    static deserialize(jsonStr, module) {\n      let jsonArr = JSON.parse(jsonStr);\n      let arr = [];\n      let vdom;\n      jsonArr.forEach(item => {\n        arr.push(handleCls(item));\n      });\n      return arr;\n\n      function handleCls(jsonObj) {\n        if (!nodom.Util.isObject(jsonObj)) {\n          return jsonObj;\n        }\n\n        if (jsonObj.moduleName) {\n          jsonObj.moduleName = module.name;\n        }\n\n        let retObj;\n\n        if (jsonObj.hasOwnProperty('className')) {\n          const cls = jsonObj['className'];\n          let param = [];\n\n          switch (cls) {\n            case 'Directive':\n              param = [jsonObj['type'], jsonObj['value'], vdom, module];\n              break;\n\n            case 'Event':\n              param = [jsonObj['name']];\n              break;\n          }\n\n          let clazz = eval(cls);\n\n          if (cls === 'Element') {\n            vdom = retObj;\n          }\n        } else {\n          retObj = {};\n        }\n\n        let objArr = [];\n        let arrArr = [];\n        nodom.Util.getOwnProps(jsonObj).forEach(item => {\n          if (nodom.Util.isObject(jsonObj[item])) {\n            objArr.push(item);\n          } else if (nodom.Util.isArray(jsonObj[item])) {\n            arrArr.push(item);\n          } else {\n            if (item !== 'className') {\n              retObj[item] = jsonObj[item];\n            }\n          }\n        });\n        objArr.forEach(item => {\n          retObj[item] = handleCls(jsonObj[item]);\n        });\n        arrArr.forEach(item => {\n          retObj[item] = [];\n          jsonObj[item].forEach(item1 => {\n            retObj[item].push(handleCls(item1));\n          });\n        });\n        return retObj;\n      }\n    }\n\n  }\n\n  nodom.Serializer = Serializer;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/serializer.ts?");

/***/ }),

/***/ "./core/util.ts":
/*!**********************!*\
  !*** ./core/util.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nodom;\n\n(function (nodom) {\n  class Util {\n    static genId() {\n      return this.generatedId++;\n    }\n\n    clone(srcObj, expKey) {\n      let map = new WeakMap();\n      let src = this;\n      let retObj = clone(srcObj);\n      map = null;\n      return retObj;\n\n      function clone(src) {\n        let dst;\n\n        if (this.isObject(src)) {\n          dst = new Object();\n          map.set(src, dst);\n          Object.getOwnPropertyNames(src).forEach(prop => {\n            if (expKey) {\n              if (expKey.constructor === RegExp && expKey.test(prop) || expKey.constructor === String && expKey === prop) {\n                return;\n              }\n            }\n\n            if (this.isObject(src[prop]) || this.isArray(src[prop])) {\n              let co = null;\n\n              if (!map.has(src[prop])) {\n                co = clone(src[prop]);\n                map.set(src[prop], co);\n              } else {\n                co = map.get(src[prop]);\n              }\n\n              dst[prop] = co;\n            } else {\n              dst[prop] = src[prop];\n            }\n          });\n        } else if (this.isArray(src)) {\n          dst = new Array();\n          map.set(src, dst);\n          src.forEach(function (item, i) {\n            if (this.isObject(item) || this.isArray(item)) {\n              dst[i] = clone(item);\n            } else {\n              dst[i] = item;\n            }\n          });\n        }\n\n        return dst;\n      }\n    }\n\n    static merge() {\n      for (let i = 0; i < arguments.length; i++) {\n        if (!this.isObject(arguments[i])) {\n          throw new nodom.NodomError('invoke', 'this.merge', i + '', 'object');\n        }\n      }\n\n      let retObj = Object.assign.apply(null, arguments);\n      subObj(retObj);\n      return retObj;\n\n      function subObj(retObj) {\n        for (let o in retObj) {\n          if (this.isObject(retObj[o]) || this.isArray(retObj[o])) {\n            retObj[o] = retObj[o].clone();\n          }\n        }\n      }\n    }\n\n    static assign(obj1, obj2) {\n      if (Object.assign) {\n        Object.assign(obj1, obj2);\n      } else {\n        this.getOwnProps(obj2).forEach(function (p) {\n          obj1[p] = obj2[p];\n        });\n      }\n\n      return obj1;\n    }\n\n    static getOwnProps(obj) {\n      if (!obj) {\n        return [];\n      }\n\n      return Object.getOwnPropertyNames(obj);\n    }\n\n    static isFunction(foo) {\n      return foo !== undefined && foo !== null && foo.constructor === Function;\n    }\n\n    static isArray(obj) {\n      return Array.isArray(obj);\n    }\n\n    static isObject(obj) {\n      return obj !== null && obj !== undefined && obj.constructor === Object;\n    }\n\n    static isInt(v) {\n      return Number.isInteger(v);\n    }\n\n    static isNumber(v) {\n      return typeof v === 'number';\n    }\n\n    static isBoolean(v) {\n      return typeof v === 'boolean';\n    }\n\n    static isString(v) {\n      return typeof v === 'string';\n    }\n\n    static isNumberString(v) {\n      return /^\\d+\\.?\\d*$/.test(v);\n    }\n\n    static isEmpty(obj) {\n      if (obj === null || obj === undefined) return true;\n      let tp = typeof obj;\n\n      if (this.isObject(obj)) {\n        let keys = Object.keys(obj);\n\n        if (keys !== undefined) {\n          return keys.length === 0;\n        }\n      } else if (tp === 'string') {\n        return obj === '';\n      }\n\n      return false;\n    }\n\n    static findObjByProps(obj, props, one) {\n      if (!this.isObject(obj)) {\n        throw new nodom.NodomError('invoke', 'this.findObjByProps', '0', 'Object');\n      }\n\n      one = one || false;\n      let ps = this.getOwnProps(props);\n      let find = false;\n\n      if (one === false) {\n        find = true;\n\n        for (let i = 0; i < ps.length; i++) {\n          let p = ps[i];\n\n          if (obj[p] !== props[p]) {\n            find = false;\n            break;\n          }\n        }\n      } else {\n        for (let i = 0; i < ps.length; i++) {\n          let p = ps[i];\n\n          if (obj[p] === props[p]) {\n            find = true;\n            break;\n          }\n        }\n      }\n\n      if (find) {\n        return obj;\n      }\n\n      for (let p in obj) {\n        let o = obj[p];\n\n        if (o !== null) {\n          if (this.isObject(o)) {\n            let oprops = this.getOwnProps(o);\n\n            for (let i = 0; i < oprops.length; i++) {\n              let item = o[oprops[i]];\n\n              if (item !== null && this.isObject(item)) {\n                let r = this.findObjByProps(item, props, one);\n\n                if (r !== null) {\n                  return r;\n                }\n              }\n            }\n          } else if (this.isArray(o)) {\n            for (let i = 0; i < o.length; i++) {\n              let item = o[i];\n\n              if (item !== null && this.isObject(item)) {\n                let r = this.findObjByProps(item, props, one);\n\n                if (r !== null) {\n                  return r;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n\n    static get(selector, findAll, pview) {\n      pview = pview || document;\n\n      if (findAll === true) {\n        return pview.querySelectorAll(selector);\n      }\n\n      return pview.querySelector(selector);\n    }\n\n    static append(el, dom) {\n      if (this.isNode(dom)) {\n        el.appendChild(dom);\n      } else if (this.isString(dom)) {\n        let div = this.newEl('div');\n        div.innerHTML = dom;\n      }\n    }\n\n    static isEl(el) {\n      return el instanceof HTMLElement;\n    }\n\n    static isNode(node) {\n      return node !== undefined && node !== null && (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n    }\n\n    static getTranslate(el) {\n      let tr = el.style.transform;\n      let arr;\n\n      if (tr && tr !== 'none') {\n        arr = [];\n        let vs = tr.substring(tr.indexOf('(') + 1, tr.indexOf(')') - 1);\n        let va = vs.split(',');\n\n        for (let i = 0; i < va.length; i++) {\n          arr.push(parseInt(va[i]));\n        }\n      }\n\n      if (arr) {\n        return arr;\n      }\n\n      return [0, 0, 0];\n    }\n\n    static newEl(tagName, config, text) {\n      if (!this.isString(tagName) || this.isEmpty(tagName)) {\n        throw new nodom.NodomError('invoke', 'this.newEl', '0', 'string');\n      }\n\n      let el = document.createElement(tagName);\n\n      if (this.isObject(config)) {\n        this.attr(el, config);\n      } else if (this.isString(text)) {\n        el.innerHTML = text;\n      }\n\n      return el;\n    }\n\n    static newSvgEl(tagName) {\n      return document.createElementNS(\"http://www.w3.org/2000/svg\", tagName);\n    }\n\n    static replaceNode(srcNode, nodes) {\n      if (!this.isNode(srcNode)) {\n        throw new nodom.NodomError('invoke', 'this.replaceNode', '0', 'Node');\n      }\n\n      if (!this.isNode(nodes) && !this.isArray(nodes)) {\n        throw new nodom.NodomError('invoke1', 'this.replaceNode', '1', 'Node', 'Node Array');\n      }\n\n      let pnode = srcNode.parentNode;\n      let bnode = srcNode.nextSibling;\n\n      if (pnode === null) {\n        return;\n      }\n\n      pnode.removeChild(srcNode);\n      const nodeArr = this.isArray(nodes) ? nodes : [nodes];\n      nodeArr.forEach(function (node) {\n        if (bnode === undefined || bnode === null) {\n          pnode.appendChild(node);\n        } else {\n          pnode.insertBefore(node, bnode);\n        }\n      });\n    }\n\n    static insertAfter(newNode, srcNode, pNode) {\n      if (!this.isNode(newNode)) {\n        throw new nodom.NodomError('invoke', 'this.insertAfter', '0', 'Node');\n      }\n\n      if (!this.isNode(srcNode) && !this.isNode(pNode)) {\n        throw new nodom.NodomError('invoke2', 'this.insertAfter', '1', '2', 'Node');\n      }\n\n      let bNode = null;\n\n      if (srcNode === undefined || srcNode === null) {\n        bNode = pNode.firstChild;\n      } else {\n        pNode = srcNode.parentNode;\n        bNode = srcNode.nextSibling;\n      }\n\n      if (!this.isNode(pNode)) {\n        return;\n      }\n\n      if (bNode === null) {\n        if (this.isArray(newNode)) {\n          for (let n of newNode) {\n            if (this.isEl(n)) {\n              pNode.appendChild(n);\n            }\n          }\n        } else {\n          pNode.appendChild(newNode);\n        }\n      } else {\n        if (this.isArray(newNode)) {\n          for (let n of newNode) {\n            if (this.isEl(n)) {\n              pNode.insertBefore(n, bNode);\n            }\n          }\n        } else {\n          pNode.insertBefore(newNode, bNode);\n        }\n      }\n    }\n\n    static empty(el) {\n      const me = this;\n\n      if (!me.isEl(el)) {\n        throw new nodom.NodomError('invoke', 'this.empty', '0', 'Element');\n      }\n\n      let nodes = el.childNodes;\n\n      for (let i = nodes.length - 1; i >= 0; i--) {\n        el.removeChild(nodes[i]);\n      }\n    }\n\n    static remove(node) {\n      const me = this;\n\n      if (!me.isNode(node)) {\n        throw new nodom.NodomError('invoke', 'this.remove', '0', 'Node');\n      }\n\n      if (node.parentNode !== null) {\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    static attr(el, param, value) {\n      const me = this;\n\n      if (!me.isEl(el)) {\n        throw new nodom.NodomError('invoke', 'this.attr', '0', 'Element');\n      }\n\n      if (this.isEmpty(param)) {\n        throw new nodom.NodomError('invoke', 'this.attr', '1', 'string', 'object');\n      }\n\n      if (value === undefined || value === null) {\n        if (this.isObject(param)) {\n          this.getOwnProps(param).forEach(function (k) {\n            if (k === 'value') {\n              el[k] = param[k];\n            } else {\n              el.setAttribute(k, param[k]);\n            }\n          });\n        } else if (this.isString(param)) {\n          if (param === 'value') {\n            return param[value];\n          }\n\n          return el.getAttribute(param);\n        }\n      } else {\n        if (param === 'value') {\n          el[param] = value;\n        } else {\n          el.setAttribute(param, value);\n        }\n      }\n    }\n\n    static width(el, value) {\n      if (!this.isEl(el)) {\n        throw new nodom.NodomError('invoke', 'nodom.width', '0', 'Element');\n      }\n\n      if (this.isNumber(value)) {\n        el.style.width = value + 'px';\n      } else {\n        let compStyle;\n\n        if (window.getComputedStyle) {\n          compStyle = window.getComputedStyle(el, null);\n        }\n\n        if (!compStyle) {\n          return null;\n        }\n\n        let w = parseInt(compStyle['width']);\n\n        if (value === true) {\n          let pw = parseInt(compStyle['paddingLeft']) + parseInt(compStyle['paddingRight']);\n          w -= pw;\n        }\n\n        return w;\n      }\n    }\n\n    static height(el, value) {\n      if (!this.isEl(el)) {\n        throw new nodom.NodomError('invoke', 'this.height', '0', 'Element');\n      }\n\n      if (this.isNumber(value)) {\n        el.style.height = value + 'px';\n      } else {\n        let compStyle;\n\n        if (window.getComputedStyle) {\n          compStyle = window.getComputedStyle(el, null);\n        }\n\n        if (!compStyle) {\n          return null;\n        }\n\n        let w = parseInt(compStyle['height']);\n\n        if (value === true) {\n          let pw = parseInt(compStyle['paddingTop']) + parseInt(compStyle['paddingBottom']);\n          w -= pw;\n        }\n\n        return w;\n      }\n    }\n\n    static addClass(el, cls) {\n      if (!this.isEl(el)) {\n        throw new nodom.NodomError('invoke', 'this.addClass', '0', 'Element');\n      }\n\n      if (this.isEmpty(cls)) {\n        throw new nodom.NodomError('invoke', 'this.addClass', '1', 'string');\n      }\n\n      let cn = el.className.trim();\n\n      if (this.isEmpty(cn)) {\n        el.className = cls;\n      } else {\n        let arr = cn.split(/\\s+/);\n\n        for (let i = 0; i < arr.length; i++) {\n          if (arr[i] === cls) {\n            return;\n          }\n        }\n\n        arr.push(cls);\n        el.className = arr.join(' ');\n      }\n    }\n\n    static removeClass(el, cls) {\n      if (!this.isEl(el)) {\n        throw new nodom.NodomError('invoke', 'this.removeClass', '0', 'Element');\n      }\n\n      if (this.isEmpty(cls)) {\n        throw new nodom.NodomError('invoke', 'this.removeClass', '1', 'string');\n      }\n\n      let cn = el.className.trim();\n\n      if (!this.isEmpty(cn)) {\n        let arr = cn.split(/\\s+/);\n\n        for (let i = 0; i < arr.length; i++) {\n          if (arr[i] === cls) {\n            arr.splice(i, 1);\n            el.className = arr.join(' ');\n            return;\n          }\n        }\n      }\n    }\n\n    static formatDate(srcDate, format) {\n      let timeStamp;\n\n      if (this.isString(srcDate)) {\n        let reg = new RegExp(/^\\d+$/);\n\n        if (reg.test(srcDate) === true) {\n          timeStamp = parseInt(srcDate);\n        }\n      } else if (this.isNumber(srcDate)) {\n        timeStamp = srcDate;\n      } else {\n        throw new nodom.NodomError('invoke', 'this.formatDate', '0', 'date string', 'date');\n      }\n\n      let date = new Date(timeStamp);\n\n      if (isNaN(date.getDay())) {\n        return '';\n      }\n\n      let o = {\n        \"M+\": date.getMonth() + 1,\n        \"d+\": date.getDate(),\n        \"h+\": date.getHours() % 12 === 0 ? 12 : date.getHours() % 12,\n        \"H+\": date.getHours(),\n        \"m+\": date.getMinutes(),\n        \"s+\": date.getSeconds(),\n        \"q+\": Math.floor((date.getMonth() + 3) / 3),\n        \"S\": date.getMilliseconds()\n      };\n      let week = {\n        \"0\": \"日\",\n        \"1\": \"一\",\n        \"2\": \"二\",\n        \"3\": \"三\",\n        \"4\": \"四\",\n        \"5\": \"五\",\n        \"6\": \"六\"\n      };\n\n      if (/(y+)/.test(format)) {\n        format = format.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n      }\n\n      this.getOwnProps(o).forEach(function (k) {\n        if (new RegExp(\"(\" + k + \")\").test(format)) {\n          format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n        }\n      });\n\n      if (/(E+)/.test(format)) {\n        format = format.replace(RegExp.$1, (RegExp.$1.length > 1 ? RegExp.$1.length > 2 ? \"/u661f/u671f\" : \"/u5468\" : \"\") + week[date.getDay() + \"\"]);\n      }\n\n      return format;\n    }\n\n    static compileStr(src, p1, p2, p3, p4, p5) {\n      let reg = new RegExp(/\\{.+?\\}/);\n      let r;\n      let args = arguments;\n      let str = args[0];\n\n      while ((r = reg.exec(str)) !== null) {\n        let rep;\n        let sIndex = r[0].substr(1, r[0].length - 2);\n        let pIndex = parseInt(sIndex) + 1;\n\n        if (args[pIndex] !== undefined) {\n          rep = args[pIndex];\n        } else {\n          rep = '';\n        }\n\n        str = str.replace(reg, rep);\n      }\n\n      return str;\n    }\n\n    static addStrQuot(srcStr, quot) {\n      srcStr = srcStr.replace(/\\'/g, '\\\\\\'');\n      srcStr = srcStr.replace(/\\\"/g, '\\\\\\\"');\n      srcStr = srcStr.replace(/\\`/g, '\\\\\\`');\n      quot = quot || '\"';\n      srcStr = quot + srcStr + quot;\n      return srcStr;\n    }\n\n    static apply(foo, obj, args) {\n      if (!foo) {\n        return;\n      }\n\n      return Reflect.apply(foo, obj || null, args);\n    }\n\n  }\n\n  Util.generatedId = 1;\n  nodom.Util = Util;\n})(nodom || (nodom = {}));\n\n//# sourceURL=webpack://nodom/./core/util.ts?");

/***/ }),

/***/ 0:
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./core/nodom.ts ./core/application.ts ./core/util.ts ./core/compiler.ts ./core/directive.ts ./core/directivefactory.ts ./core/directivemanager.ts ./core/element.ts ./core/nodomerror.ts ./core/nodomevent.ts ./core/expression.ts ./core/expressionfactory.ts ./core/factory.ts ./core/filter.ts ./core/filterfactory.ts ./core/filtermanager.ts ./core/linker.ts ./core/messagequeue.ts ./core/methodfactory.ts ./core/model.ts ./core/modelfactory.ts ./core/module.ts ./core/modulefactory.ts ./core/renderer.ts ./core/router.ts ./core/scheduler.ts ./core/serializer.ts ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./core/nodom.ts */\"./core/nodom.ts\");\n__webpack_require__(/*! ./core/application.ts */\"./core/application.ts\");\n__webpack_require__(/*! ./core/util.ts */\"./core/util.ts\");\n__webpack_require__(/*! ./core/compiler.ts */\"./core/compiler.ts\");\n__webpack_require__(/*! ./core/directive.ts */\"./core/directive.ts\");\n__webpack_require__(/*! ./core/directivefactory.ts */\"./core/directivefactory.ts\");\n__webpack_require__(/*! ./core/directivemanager.ts */\"./core/directivemanager.ts\");\n__webpack_require__(/*! ./core/element.ts */\"./core/element.ts\");\n__webpack_require__(/*! ./core/nodomerror.ts */\"./core/nodomerror.ts\");\n__webpack_require__(/*! ./core/nodomevent.ts */\"./core/nodomevent.ts\");\n__webpack_require__(/*! ./core/expression.ts */\"./core/expression.ts\");\n__webpack_require__(/*! ./core/expressionfactory.ts */\"./core/expressionfactory.ts\");\n__webpack_require__(/*! ./core/factory.ts */\"./core/factory.ts\");\n__webpack_require__(/*! ./core/filter.ts */\"./core/filter.ts\");\n__webpack_require__(/*! ./core/filterfactory.ts */\"./core/filterfactory.ts\");\n__webpack_require__(/*! ./core/filtermanager.ts */\"./core/filtermanager.ts\");\n__webpack_require__(/*! ./core/linker.ts */\"./core/linker.ts\");\n__webpack_require__(/*! ./core/messagequeue.ts */\"./core/messagequeue.ts\");\n__webpack_require__(/*! ./core/methodfactory.ts */\"./core/methodfactory.ts\");\n__webpack_require__(/*! ./core/model.ts */\"./core/model.ts\");\n__webpack_require__(/*! ./core/modelfactory.ts */\"./core/modelfactory.ts\");\n__webpack_require__(/*! ./core/module.ts */\"./core/module.ts\");\n__webpack_require__(/*! ./core/modulefactory.ts */\"./core/modulefactory.ts\");\n__webpack_require__(/*! ./core/renderer.ts */\"./core/renderer.ts\");\n__webpack_require__(/*! ./core/router.ts */\"./core/router.ts\");\n__webpack_require__(/*! ./core/scheduler.ts */\"./core/scheduler.ts\");\nmodule.exports = __webpack_require__(/*! ./core/serializer.ts */\"./core/serializer.ts\");\n\n\n//# sourceURL=webpack://nodom/multi_./core/nodom.ts_./core/application.ts_./core/util.ts_./core/compiler.ts_./core/directive.ts_./core/directivefactory.ts_./core/directivemanager.ts_./core/element.ts_./core/nodomerror.ts_./core/nodomevent.ts_./core/expression.ts_./core/expressionfactory.ts_./core/factory.ts_./core/filter.ts_./core/filterfactory.ts_./core/filtermanager.ts_./core/linker.ts_./core/messagequeue.ts_./core/methodfactory.ts_./core/model.ts_./core/modelfactory.ts_./core/module.ts_./core/modulefactory.ts_./core/renderer.ts_./core/router.ts_./core/scheduler.ts_./core/serializer.ts?");

/***/ })

/******/ });
});